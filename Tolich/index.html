<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªçc Li·ªáu S·ªë: H√¨nh LƒÉng Tr·ª• ƒê·ª©ng - L·ªãch ƒê·ªÉ B√†n</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* Giao di·ªán 3D container */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* Ti√™u ƒë·ªÅ & H∆∞·ªõng d·∫´n thao t√°c */
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            text-align: left;
            color: #333;
            pointer-events: none;
            z-index: 10;
            background: rgba(255,255,255,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-width: 300px;
        }
        #info h2 { margin: 0 0 5px 0; font-size: 18px; color: #B22222; }
        #info p { margin: 0; font-size: 13px; color: #555; }

        /* B·∫£ng H·ªçc T·∫≠p (Learning Panel) */
        #learning-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 320px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .panel-header { font-size: 18px; font-weight: bold; color: #2E8B57; border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 15px; }
        
        .question-box { background: #f9f9f9; padding: 15px; border-radius: 8px; border-left: 4px solid #B22222; margin-bottom: 15px; }
        .question-text { font-weight: 600; margin-bottom: 10px; display: block; }
        
        .input-group { display: flex; gap: 5px; margin-bottom: 10px; }
        input[type="number"] { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        
        button { cursor: pointer; border: none; padding: 8px 15px; border-radius: 4px; font-weight: bold; transition: background 0.2s; margin-bottom: 5px; width: 100%; }
        #checkBtn { background-color: #2E8B57; color: white; width: auto; margin-bottom: 0; }
        #checkBtn:hover { background-color: #257045; }
        
        #guideBtn { background-color: #FF8C00; color: white; }
        #guideBtn:hover { background-color: #e07b00; }

        #newExerciseBtn { background-color: #4682B4; color: white; margin-top: 10px; }
        #newExerciseBtn:hover { background-color: #36648b; }

        /* Form t·∫°o b√†i t·∫≠p m·ªõi */
        #customForm { display: none; background: #eee; padding: 10px; border-radius: 8px; margin-top: 10px; animation: fadeIn 0.3s; }
        .custom-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 14px; }
        .custom-row input { width: 60px; padding: 4px; }
        #applyCustomBtn { background-color: #2E8B57; color: white; margin-top: 5px; }

        .feedback { margin-top: 10px; font-weight: bold; min-height: 20px; font-size: 14px; }
        .correct { color: green; }
        .incorrect { color: red; }

        /* Ph·∫ßn H∆∞·ªõng d·∫´n */
        #guideContent { margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 10px; display: none; }
        #guideContent.show { display: block; animation: fadeIn 0.5s; }
        .step { margin-bottom: 10px; font-size: 14px; line-height: 1.5; }
        .step strong { color: #333; display: block; margin-bottom: 2px; }
        .math { font-family: "Times New Roman", Times, serif; font-style: italic; background: #eee; padding: 0 4px; border-radius: 3px; font-weight: bold; color: #00008B; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        @media (max-width: 600px) {
            #learning-panel { top: auto; bottom: 0; left: 0; right: 0; width: 100%; border-radius: 15px 15px 0 0; max-height: 60vh; }
            #info { display: none; }
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>M√¥ h√¨nh L·ªãch ƒê·ªÉ B√†n 3D</h2>
        <p>üñ±Ô∏è <strong>Xoay:</strong> Gi·ªØ chu·ªôt tr√°i</p>
        <p>üñêÔ∏è <strong>Di chuy·ªÉn:</strong> Gi·ªØ chu·ªôt ph·∫£i</p>
        <p>üîç <strong>Zoom:</strong> LƒÉn chu·ªôt gi·ªØa</p>
    </div>

    <div id="learning-panel">
        <div class="panel-header">üéì G√≥c H·ªçc T·∫≠p</div>
        
        <div class="question-box">
            <span class="question-text">C√¢u h·ªèi: T√≠nh di·ªán t√≠ch xung quanh c·ªßa chi·∫øc l·ªãch (cm¬≤)?</span>
            <div style="font-size: 12px; color: #666; margin-bottom: 8px;">(L√†m tr√≤n k·∫øt qu·∫£ ƒë·∫øn h√†ng ƒë∆°n v·ªã)</div>
            
            <div class="input-group">
                <input type="number" id="userAnswer" placeholder="Nh·∫≠p ƒë√°p √°n...">
                <button id="checkBtn">Ki·ªÉm tra</button>
            </div>
            <div id="feedback" class="feedback"></div>
        </div>

        <button id="guideBtn">üí° H∆∞·ªõng d·∫´n c√°ch t√≠nh</button>
        <div id="guideContent"></div>

        <!-- N√∫t v√† Form t·∫°o b√†i t·∫≠p m·ªõi -->
        <button id="newExerciseBtn">‚ûï T·∫°o b√†i t·∫≠p m·ªõi</button>
        
        <div id="customForm">
            <div class="custom-row">
                <label>C·∫°nh b√™n (cm):</label>
                <input type="number" id="inputSlant" value="15" min="1">
            </div>
            <div class="custom-row">
                <label>C·∫°nh ƒë√°y (cm):</label>
                <input type="number" id="inputBase" value="7" min="1">
            </div>
            <div class="custom-row">
                <label>Chi·ªÅu d√†i (cm):</label>
                <input type="number" id="inputLength" value="16" min="1">
            </div>
            <button id="applyCustomBtn">√Åp d·ª•ng k√≠ch th∆∞·ªõc m·ªõi</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- GLOBAL VARIABLES (K√≠ch th∆∞·ªõc m·∫∑c ƒë·ªãnh) ---
        let slantHeight = 15; // C·∫°nh b√™n
        let width = 16;       // Chi·ªÅu d√†i lƒÉng tr·ª•
        let baseDepth = 7;    // C·∫°nh ƒë√°y
        let correctAnswer = 0;

        // C√°c bi·∫øn Scene Three.js
        let scene, camera, renderer, controls;
        let calendarGroup, dimensionGroup; // Nh√≥m ch·ª©a model v√† nh√≥m ch·ª©a nh√£n k√≠ch th∆∞·ªõc
        
        // V·∫≠t li·ªáu d√πng chung
        const coverMaterial = new THREE.MeshStandardMaterial({ color: 0xB22222, roughness: 0.6, side: THREE.DoubleSide });
        const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.7, roughness: 0.2 });

        init();
        animate();

        function init() {
            // Setup c∆° b·∫£n
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 20, 30);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // √Ånh s√°ng
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);
            
            // M·∫∑t s√†n
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.ShadowMaterial({ opacity: 0.1 }));
            plane.rotation.x = -Math.PI / 2; plane.receiveShadow = true; scene.add(plane);
            scene.add(new THREE.GridHelper(100, 50, 0xcccccc, 0xe5e5e5));

            // Kh·ªüi t·∫°o model l·∫ßn ƒë·∫ßu
            rebuildModel();
            updateMathLogic();

            // Setup s·ª± ki·ªán Resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- H√ÄM X√ÇY D·ª∞NG L·∫†I MODEL 3D ---
        function rebuildModel() {
            // 1. X√≥a model c≈© n·∫øu c√≥
            if (calendarGroup) scene.remove(calendarGroup);
            if (dimensionGroup) scene.remove(dimensionGroup);

            calendarGroup = new THREE.Group();
            dimensionGroup = new THREE.Group();
            scene.add(calendarGroup);
            scene.add(dimensionGroup);

            // 2. T√≠nh to√°n c√°c th√¥ng s·ªë h√¨nh h·ªçc ph√°i sinh
            const halfBase = baseDepth / 2;
            const verticalHeight = Math.sqrt(Math.max(0, Math.pow(slantHeight, 2) - Math.pow(halfBase, 2)));
            // N·∫øu kh√¥ng t·∫°o th√†nh tam gi√°c (slantHeight < halfBase), verticalHeight s·∫Ω l√† 0 ho·∫∑c NaN
            const tiltAngle = (slantHeight > halfBase) ? Math.asin(halfBase / slantHeight) : 0;

            const thickness = 0.2;
            const coverGeo = new THREE.BoxGeometry(width, slantHeight, thickness);

            // 3. V·∫Ω B√¨a
            const frontCover = new THREE.Mesh(coverGeo, coverMaterial);
            frontCover.position.set(0, verticalHeight / 2, halfBase / 2);
            frontCover.rotation.x = -tiltAngle;
            frontCover.castShadow = true; calendarGroup.add(frontCover);

            const backCover = new THREE.Mesh(coverGeo, coverMaterial);
            backCover.position.set(0, verticalHeight / 2, -halfBase / 2);
            backCover.rotation.x = tiltAngle;
            backCover.castShadow = true; calendarGroup.add(backCover);

            const bottomGeo = new THREE.BoxGeometry(width, baseDepth - 0.5, thickness);
            const bottomCover = new THREE.Mesh(bottomGeo, coverMaterial);
            bottomCover.rotation.x = -Math.PI / 2;
            bottomCover.position.y = 0.1;
            calendarGroup.add(bottomCover);

            // 4. V·∫Ω Trang L·ªãch
            function addPages(isFrontSide) {
                const pageCount = 6;
                for(let i = 0; i < pageCount; i++) {
                    let currentMonth = isFrontSide ? (5 - i) : (6 + i);
                    const texture = createCalendarTexture(currentMonth);
                    const pageMat = new THREE.MeshBasicMaterial({ map: texture }); 
                    const materials = [whiteMaterial, whiteMaterial, whiteMaterial, whiteMaterial, pageMat, pageMat];
                    const page = new THREE.Mesh(new THREE.BoxGeometry(width - 1, slantHeight - 1, 0.05), materials);
                    const zOffset = 0.2 + (i * 0.06); 
                    
                    if (isFrontSide) {
                        page.position.set(0, verticalHeight / 2 - 0.5, (halfBase / 2) + zOffset);
                        page.rotation.x = -tiltAngle;
                    } else {
                        page.position.set(0, verticalHeight / 2 - 0.5, -(halfBase / 2) - zOffset);
                        page.rotation.x = tiltAngle; page.rotation.y = Math.PI; 
                    }
                    calendarGroup.add(page);
                }
            }
            addPages(true); addPages(false);

            // 5. V·∫Ω L√≤ Xo
            const ringCount = Math.max(5, Math.floor(width / 1.5)); // S·ªë l∆∞·ª£ng l√≤ xo t√πy theo chi·ªÅu d√†i
            const ringRadius = 0.6; const tubeRadius = 0.08;
            const startX = -width / 2 + 1;
            const stepX = (width - 2) / (ringCount - 1);
            for (let i = 0; i < ringCount; i++) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(ringRadius, tubeRadius, 8, 20), ringMaterial);
                ring.position.set(startX + i * stepX, verticalHeight, 0);
                ring.rotation.y = Math.PI / 2;
                calendarGroup.add(ring);
            }

            // 6. V·∫Ω ƒê∆∞·ªùng K√≠ch Th∆∞·ªõc (C·∫≠p nh·∫≠t v·ªã tr√≠ m·ªõi)
            const yOffset = 0.25;
            // C·∫°nh b√™n
            createDimensionLabel(`${slantHeight} cm`, 
                new THREE.Vector3(-width/2, verticalHeight, 0), 
                new THREE.Vector3(-width/2, 0, halfBase), 
                new THREE.Vector3(-2, 0, 0));
            // Chi·ªÅu d√†i
            createDimensionLabel(`${width} cm`, 
                new THREE.Vector3(-width/2, yOffset, halfBase), 
                new THREE.Vector3(width/2, yOffset, halfBase), 
                new THREE.Vector3(0, 0, 2));
            // C·∫°nh ƒë√°y
            createDimensionLabel(`${baseDepth} cm`, 
                new THREE.Vector3(width/2 + 1, yOffset, halfBase), 
                new THREE.Vector3(width/2 + 1, yOffset, -halfBase), 
                new THREE.Vector3(1, 0, 0));
        }

        // --- C·∫¨P NH·∫¨T LOGIC TO√ÅN & H∆Ø·ªöNG D·∫™N ---
        function updateMathLogic() {
            // T√≠nh to√°n ƒë√°p √°n
            const perimeter = slantHeight + slantHeight + baseDepth;
            correctAnswer = perimeter * width;

            // C·∫≠p nh·∫≠t n·ªôi dung H∆∞·ªõng D·∫´n (Guide HTML)
            const guideHTML = `
                <div class="step">
                    <strong>B∆∞·ªõc 1: C√¥ng th·ª©c t√≠nh</strong>
                    <span class="math">S_xq = Chuvi_ƒë√°y √ó Chi·ªÅu_cao</span>
                </div>
                <div class="step">
                    <strong>B∆∞·ªõc 2: X√°c ƒë·ªãnh c√°c c·∫°nh</strong>
                    - C√°c c·∫°nh ƒë√°y tam gi√°c: <b>${slantHeight}cm, ${slantHeight}cm, ${baseDepth}cm</b>.<br>
                    - Chi·ªÅu cao lƒÉng tr·ª• (chi·ªÅu d√†i l·ªãch): <b>${width}cm</b>.
                </div>
                <div class="step">
                    <strong>B∆∞·ªõc 3: T√≠nh Chu vi ƒë√°y (C)</strong>
                    <span class="math">C = ${slantHeight} + ${slantHeight} + ${baseDepth} = ${perimeter} cm</span>
                </div>
                <div class="step">
                    <strong>B∆∞·ªõc 4: T√≠nh Di·ªán t√≠ch xung quanh</strong>
                    <span class="math">S_xq = ${perimeter} √ó ${width} = ${correctAnswer} cm¬≤</span>
                </div>
            `;
            document.getElementById('guideContent').innerHTML = guideHTML;
            
            // Reset input v√† feedback
            document.getElementById('userAnswer').value = '';
            const feedback = document.getElementById('feedback');
            feedback.textContent = '';
            feedback.className = 'feedback';
        }

        // --- X·ª¨ L√ù UI S·ª∞ KI·ªÜN ---
        const newExerciseBtn = document.getElementById('newExerciseBtn');
        const customForm = document.getElementById('customForm');
        const applyCustomBtn = document.getElementById('applyCustomBtn');
        const guideBtn = document.getElementById('guideBtn');
        const guideContent = document.getElementById('guideContent');
        const checkBtn = document.getElementById('checkBtn');
        const userAnswerInput = document.getElementById('userAnswer');
        const feedback = document.getElementById('feedback');

        // Toggle form nh·∫≠p li·ªáu
        newExerciseBtn.addEventListener('click', () => {
            if (customForm.style.display === 'block') {
                customForm.style.display = 'none';
            } else {
                customForm.style.display = 'block';
            }
        });

        // √Åp d·ª•ng k√≠ch th∆∞·ªõc m·ªõi
        applyCustomBtn.addEventListener('click', () => {
            const s = parseFloat(document.getElementById('inputSlant').value);
            const b = parseFloat(document.getElementById('inputBase').value);
            const l = parseFloat(document.getElementById('inputLength').value);

            if (s <= 0 || b <= 0 || l <= 0) {
                alert("Vui l√≤ng nh·∫≠p s·ªë d∆∞∆°ng!"); return;
            }
            if (s * 2 <= b) {
                alert("Kh√¥ng th·ªÉ t·∫°o th√†nh tam gi√°c! C·∫°nh b√™n ph·∫£i l·ªõn h∆°n m·ªôt n·ª≠a c·∫°nh ƒë√°y."); return;
            }

            // C·∫≠p nh·∫≠t bi·∫øn to√†n c·ª•c
            slantHeight = s;
            baseDepth = b;
            width = l;

            // X√¢y d·ª±ng l·∫°i m√¥ h√¨nh v√† to√°n
            rebuildModel();
            updateMathLogic();
            
            // ·∫®n form
            customForm.style.display = 'none';
            // ·∫®n h∆∞·ªõng d·∫´n n·∫øu ƒëang m·ªü ƒë·ªÉ h·ªçc sinh t·ª± l√†m l·∫°i
            guideContent.classList.remove('show');
            guideBtn.textContent = "üí° H∆∞·ªõng d·∫´n c√°ch t√≠nh";
        });

        // Ki·ªÉm tra ƒë√°p √°n
        checkBtn.addEventListener('click', () => {
            const userVal = parseFloat(userAnswerInput.value);
            if (isNaN(userVal)) {
                feedback.textContent = "Vui l√≤ng nh·∫≠p s·ªë!";
                feedback.className = "feedback incorrect";
                return;
            }
            if (Math.abs(userVal - correctAnswer) <= 1) {
                feedback.textContent = `Ch√≠nh x√°c! K·∫øt qu·∫£ l√† ${correctAnswer} cm¬≤.`;
                feedback.className = "feedback correct";
            } else {
                feedback.textContent = "Ch∆∞a ƒë√∫ng. H√£y xem l·∫°i k√≠ch th∆∞·ªõc ho·∫∑c m·ªü H∆∞·ªõng d·∫´n.";
                feedback.className = "feedback incorrect";
            }
        });

        // Toggle h∆∞·ªõng d·∫´n
        guideBtn.addEventListener('click', () => {
            if (guideContent.classList.contains('show')) {
                guideContent.classList.remove('show');
                guideBtn.textContent = "üí° H∆∞·ªõng d·∫´n c√°ch t√≠nh";
            } else {
                guideContent.classList.add('show');
                guideBtn.textContent = "·∫®n h∆∞·ªõng d·∫´n";
            }
        });

        // --- C√ÅC H√ÄM PH·ª§ TR·ª¢ (Drawing) ---
        function createDimensionLabel(text, startPoint, endPoint, offsetDir) {
            const group = new THREE.Group();
            const arrowColor = 0xcc0000;
            const p1 = startPoint.clone().add(offsetDir);
            const p2 = endPoint.clone().add(offsetDir);

            const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: arrowColor }));
            group.add(line);

            const coneGeo = new THREE.ConeGeometry(0.2, 0.6, 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: arrowColor });
            const cone1 = new THREE.Mesh(coneGeo, coneMat);
            cone1.position.copy(p1); cone1.lookAt(p2); cone1.rotateX(-Math.PI/2); group.add(cone1);
            const cone2 = new THREE.Mesh(coneGeo, coneMat);
            cone2.position.copy(p2); cone2.lookAt(p1); cone2.rotateX(-Math.PI/2); group.add(cone2);

            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = "Bold 40px Arial"; ctx.fillStyle = "black"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 128, 64);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            
            const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            const textOffset = offsetDir.clone().normalize().multiplyScalar(0.5);
            sprite.position.copy(midPoint).add(textOffset);
            sprite.scale.set(6, 3, 1);
            group.add(sprite);
            dimensionGroup.add(group);
        }

        // Texture functions (gi·ªØ nguy√™n logic c≈© nh∆∞ng g·ªçn h∆°n)
        function drawApricotBlossom(ctx) {
            ctx.beginPath(); ctx.moveTo(0, 240); ctx.bezierCurveTo(150, 200, 200, 280, 400, 100);
            ctx.lineWidth = 8; ctx.strokeStyle = '#5D4037'; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(250, 180); ctx.quadraticCurveTo(300, 150, 350, 180);
            ctx.lineWidth = 4; ctx.stroke();
            function f(cx, cy, c) { ctx.fillStyle=c; ctx.beginPath(); ctx.arc(cx,cy,c==='#FFD700'?10:5,0,Math.PI*2); ctx.fill(); }
            [[400,100],[350,180],[250,180],[300,120],[150,210],[80,230]].forEach(p=>f(p[0],p[1],'#FFD700'));
            [[400,100],[350,180],[250,180],[300,120],[150,210],[80,230]].forEach(p=>f(p[0],p[1],'#FF4500'));
        }
        function drawPineTree(ctx) {
            ctx.fillStyle="#E0F7FA"; ctx.beginPath(); ctx.ellipse(256,220,200,30,0,0,Math.PI*2); ctx.fill();
            ctx.fillStyle="#5D4037"; ctx.fillRect(236,180,40,40);
            ctx.fillStyle="#2E7D32"; 
            [[156,180,356,180,256,100],[176,120,336,120,256,60],[196,70,316,70,256,30]].forEach(c=>{
                ctx.beginPath(); ctx.moveTo(c[0],c[1]); ctx.lineTo(c[2],c[3]); ctx.lineTo(c[4],c[5]); ctx.fill();
            });
            ctx.fillStyle="#FFD700"; ctx.beginPath(); ctx.arc(256,30,8,0,Math.PI*2); ctx.fill();
        }
        function createCalendarTexture(monthIndex) {
            const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=512;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle='#fff'; ctx.fillRect(0,0,512,512);
            const cols=['#FF9A9E','#FECFEF','#A18CD1','#FBC2EB','#8FD3F4','#84FAB0','#ffc3a0','#ffafbd','#c9ffbf','#ffcc33','#2193b0','#6dd5ed'];
            ctx.fillStyle=cols[monthIndex%12]; ctx.fillRect(20,20,472,220);
            
            if(monthIndex%12===0) { drawApricotBlossom(ctx); ctx.fillStyle='#d00'; ctx.font='italic bold 25px Arial'; ctx.textAlign='right'; ctx.fillText("Happy New Year",470,60); }
            else if(monthIndex%12===11) { drawPineTree(ctx); ctx.fillStyle='#fff'; ctx.font='italic bold 25px Arial'; ctx.textAlign='left'; ctx.fillText("Merry Christmas",30,60); }
            else { ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.beginPath(); ctx.arc(400,80,40,0,Math.PI*2); ctx.fill(); }
            
            ctx.strokeStyle="#333"; ctx.lineWidth=2; ctx.strokeRect(20,20,472,220);
            ctx.fillStyle=monthIndex%12===0?'#d00':(monthIndex%12===11?'#006400':'#000');
            ctx.font='bold 50px Arial'; ctx.textAlign='center'; ctx.fillText(`TH√ÅNG ${monthIndex+1}`,256,300);
            
            ctx.font='bold 24px monospace'; ctx.fillStyle='#333';
            let d=1, startX=60, startY=350;
            ['CN','T2','T3','T4','T5','T6','T7'].forEach((t,i)=>{ ctx.fillStyle=i===0?'#d00':'#000'; ctx.fillText(t,startX+i*60,startY-30); });
            for(let r=0;r<5;r++) for(let c=0;c<7;c++) { if(d>30) break; ctx.fillStyle=c===0?'#d00':'#333'; ctx.fillText(d++,startX+c*60,startY+r*40); }
            
            const tex = new THREE.CanvasTexture(cvs); tex.colorSpace=THREE.SRGBColorSpace; return tex;
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>
</html>