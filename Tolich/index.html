<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªçc Li·ªáu S·ªë: H√¨nh LƒÉng Tr·ª• ƒê·ª©ng - L·ªãch ƒê·ªÉ B√†n 2026</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            text-align: left;
            color: #333;
            pointer-events: none;
            z-index: 10;
            background: rgba(255,255,255,0.8);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-width: 300px;
        }
        #info h2 { margin: 0 0 5px 0; font-size: 18px; color: #B22222; }
        #info p { margin: 0; font-size: 13px; color: #555; }

        #learning-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 320px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 20;
            max-height: 90vh;
            overflow-y: auto;
        }

        .panel-header { font-size: 18px; font-weight: bold; color: #2E8B57; border-bottom: 2px solid #eee; padding-bottom: 10px; margin-bottom: 15px; }
        .question-box { background: #f9f9f9; padding: 15px; border-radius: 8px; border-left: 4px solid #B22222; margin-bottom: 15px; }
        .question-text { font-weight: 600; margin-bottom: 10px; display: block; }
        .input-group { display: flex; gap: 5px; margin-bottom: 10px; }
        input[type="number"] { flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        button { cursor: pointer; border: none; padding: 8px 15px; border-radius: 4px; font-weight: bold; transition: background 0.2s; margin-bottom: 5px; width: 100%; }
        #checkBtn { background-color: #2E8B57; color: white; width: auto; margin-bottom: 0; }
        #guideBtn { background-color: #FF8C00; color: white; }
        #newExerciseBtn { background-color: #4682B4; color: white; margin-top: 10px; }
        #customForm { display: none; background: #eee; padding: 10px; border-radius: 8px; margin-top: 10px; }
        .feedback { margin-top: 10px; font-weight: bold; min-height: 20px; font-size: 14px; }
        .correct { color: green; }
        .incorrect { color: red; }
        #guideContent { margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 10px; display: none; }
        #guideContent.show { display: block; }
        .math { font-family: "Times New Roman", Times, serif; font-style: italic; background: #eee; padding: 0 4px; border-radius: 3px; font-weight: bold; color: #00008B; }
    </style>
</head>
<body>
    <div id="info">
        <h2>L·ªãch T·∫øt 2026 - H·ªçc H√¨nh H·ªçc 3D</h2>
        <p>üñ±Ô∏è <strong>Xoay:</strong> Chu·ªôt tr√°i</p>
        <p>üîç <strong>Zoom:</strong> Cu·ªôn chu·ªôt</p>
    </div>

    <div id="learning-panel">
        <div class="panel-header">üéì G√≥c H·ªçc T·∫≠p</div>
        <div class="question-box">
            <span class="question-text">T√≠nh di·ªán t√≠ch xung quanh (cm¬≤)?</span>
            <div class="input-group">
                <input type="number" id="userAnswer" placeholder="ƒê√°p √°n...">
                <button id="checkBtn">Ki·ªÉm tra</button>
            </div>
            <div id="feedback" class="feedback"></div>
        </div>
        <button id="guideBtn">üí° H∆∞·ªõng d·∫´n c√°ch t√≠nh</button>
        <div id="guideContent"></div>
        <button id="newExerciseBtn">‚ûï ƒê·ªïi k√≠ch th∆∞·ªõc l·ªãch</button>
        <div id="customForm">
            <input type="number" id="inputSlant" value="15" placeholder="C·∫°nh b√™n">
            <input type="number" id="inputBase" value="7" placeholder="C·∫°nh ƒë√°y">
            <input type="number" id="inputLength" value="16" placeholder="Chi·ªÅu d√†i">
            <button id="applyCustomBtn" style="background:#2E8B57; color:white; margin-top:5px;">C·∫≠p nh·∫≠t</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let slantHeight = 15; 
        let width = 16;       
        let baseDepth = 7;    
        let correctAnswer = 0;

        let scene, camera, renderer, controls, calendarGroup, dimensionGroup;
        
        const coverMaterial = new THREE.MeshStandardMaterial({ color: 0xB22222, roughness: 0.6, side: THREE.DoubleSide });
        const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
        const ringMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 20, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // √Ånh s√°ng
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(15, 25, 15);
            dirLight.castShadow = true;
            // C·∫•u h√¨nh b√≥ng ƒë·ªï m·ªãn h∆°n
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            scene.add(dirLight);

            // --- TH√äM L∆Ø·ªöI N·ªÄN (GRID) ---
            const grid = new THREE.GridHelper(100, 50, 0xcccccc, 0xe5e5e5);
            scene.add(grid);

            // Th√™m m·∫∑t ph·∫≥ng nh·∫≠n b√≥ng ƒë·ªï ·∫©n d∆∞·ªõi l∆∞·ªõi
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.ShadowMaterial({ opacity: 0.1 })
            );
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            rebuildModel();
            updateMathLogic();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createDimensionLabel(text, startPoint, endPoint, offsetDir) {
            const group = new THREE.Group();
            const arrowColor = 0xcc0000;
            const p1 = startPoint.clone().add(offsetDir);
            const p2 = endPoint.clone().add(offsetDir);

            const lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: arrowColor }));
            group.add(line);

            const coneGeo = new THREE.ConeGeometry(0.2, 0.6, 8);
            const coneMat = new THREE.MeshBasicMaterial({ color: arrowColor });
            
            const cone1 = new THREE.Mesh(coneGeo, coneMat);
            cone1.position.copy(p1); 
            cone1.lookAt(p2); 
            cone1.rotateX(-Math.PI/2); 
            group.add(cone1);

            const cone2 = new THREE.Mesh(coneGeo, coneMat);
            cone2.position.copy(p2); 
            cone2.lookAt(p1); 
            cone2.rotateX(-Math.PI/2); 
            group.add(cone2);

            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = "Bold 40px Arial"; ctx.fillStyle = "black"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(text, 128, 64);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            
            const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            const textOffset = offsetDir.clone().normalize().multiplyScalar(0.8);
            sprite.position.copy(midPoint).add(textOffset);
            sprite.scale.set(6, 3, 1);
            group.add(sprite);
            
            dimensionGroup.add(group);
        }

        function rebuildModel() {
            if (calendarGroup) scene.remove(calendarGroup);
            if (dimensionGroup) scene.remove(dimensionGroup);

            calendarGroup = new THREE.Group();
            dimensionGroup = new THREE.Group();
            scene.add(calendarGroup);
            scene.add(dimensionGroup);

            const halfBase = baseDepth / 2;
            const verticalHeight = Math.sqrt(Math.max(0, Math.pow(slantHeight, 2) - Math.pow(halfBase, 2)));
            const tiltAngle = Math.asin(halfBase / slantHeight);
            const thickness = 0.2;

            const coverGeo = new THREE.BoxGeometry(width, slantHeight, thickness);
            const frontCover = new THREE.Mesh(coverGeo, coverMaterial);
            frontCover.position.set(0, verticalHeight / 2, halfBase / 2);
            frontCover.rotation.x = -tiltAngle;
            frontCover.castShadow = true;
            calendarGroup.add(frontCover);

            const backCover = new THREE.Mesh(coverGeo, coverMaterial);
            backCover.position.set(0, verticalHeight / 2, -halfBase / 2);
            backCover.rotation.x = tiltAngle;
            backCover.castShadow = true;
            calendarGroup.add(backCover);

            const bottomCover = new THREE.Mesh(new THREE.BoxGeometry(width, baseDepth, thickness), coverMaterial);
            bottomCover.rotation.x = Math.PI / 2;
            bottomCover.position.y = 0.05;
            bottomCover.receiveShadow = true;
            calendarGroup.add(bottomCover);

            function addPages(isFront) {
                const monthIdx = isFront ? 0 : 1; 
                const texture = createCalendarTexture(monthIdx); 
                const pageMat = new THREE.MeshBasicMaterial({ map: texture });
                const mats = [whiteMaterial, whiteMaterial, whiteMaterial, whiteMaterial, pageMat, whiteMaterial];
                const page = new THREE.Mesh(new THREE.BoxGeometry(width - 0.8, slantHeight - 0.8, 0.05), mats);
                
                if (isFront) {
                    page.position.set(0, verticalHeight / 2, halfBase / 2 + 0.15);
                    page.rotation.x = -tiltAngle;
                } else {
                    page.position.set(0, verticalHeight / 2, -halfBase / 2 - 0.15);
                    page.rotation.x = tiltAngle;
                    page.rotation.y = Math.PI;
                }
                page.castShadow = true;
                calendarGroup.add(page);
            }
            addPages(true);
            addPages(false);

            const ringCount = 12;
            for (let i = 0; i < ringCount; i++) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.06, 8, 16), ringMaterial);
                ring.position.set(-width/2 + 1 + (i * (width-2)/(ringCount-1)), verticalHeight, 0);
                ring.rotation.y = Math.PI / 2;
                ring.castShadow = true;
                calendarGroup.add(ring);
            }

            const offset = 1.5;
            createDimensionLabel(`${slantHeight} cm`, 
                new THREE.Vector3(-width/2, verticalHeight, 0), 
                new THREE.Vector3(-width/2, 0, halfBase), 
                new THREE.Vector3(-1, 0, 1));
            
            createDimensionLabel(`${width} cm`, 
                new THREE.Vector3(-width/2, 0.2, halfBase), 
                new THREE.Vector3(width/2, 0.2, halfBase), 
                new THREE.Vector3(0, 0, offset));

            createDimensionLabel(`${baseDepth} cm`, 
                new THREE.Vector3(width/2 + 0.5, 0.2, halfBase), 
                new THREE.Vector3(width/2 + 0.5, 0.2, -halfBase), 
                new THREE.Vector3(1, 0, 0));
        }

        function drawDecoration(ctx, type) {
            ctx.save();
            ctx.strokeStyle = '#5D4037';
            ctx.lineWidth = 6; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(480, 220); ctx.bezierCurveTo(400, 150, 450, 100, 320, 50); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(350, 65); ctx.lineTo(380, 20); ctx.stroke();
            const flowerColor = (type === 'mai') ? '#FFD700' : '#FF69B4';
            const centerColor = (type === 'mai') ? '#FF8C00' : '#D00060';
            const points = [[450, 180], [380, 120], [320, 50], [380, 25], [410, 140], [460, 100]];
            points.forEach(p => {
                const x = p[0]; const y = p[1];
                ctx.fillStyle = flowerColor;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const angle = (i * 2 * Math.PI) / 5;
                    ctx.ellipse(x + Math.cos(angle) * 8, y + Math.sin(angle) * 8, 8, 5, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = centerColor; ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fill();
            });
            ctx.restore();
        }

        function createCalendarTexture(monthIndex) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = monthIndex === 0 ? '#B22222' : '#2E8B57';
            ctx.fillRect(0, 0, 512, 120);
            if (monthIndex === 0) {
                drawDecoration(ctx, 'mai');
                ctx.fillStyle = '#FFD700'; ctx.font = 'italic bold 22px Arial'; ctx.textAlign = 'right';
                ctx.fillText("Ch√∫c M·ª´ng NƒÉm M·ªõi", 500, 110);
            } else {
                drawDecoration(ctx, 'dao');
                ctx.fillStyle = '#FFC0CB'; ctx.font = 'italic bold 22px Arial'; ctx.textAlign = 'right';
                ctx.fillText("V·∫°n S·ª± Nh∆∞ √ù", 500, 110);
            }
            ctx.fillStyle = '#ffffff'; ctx.font = 'bold 50px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`TH√ÅNG 0${monthIndex + 1} / 2026`, 256, 75);
            const daysHeader = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];
            ctx.font = 'bold 22px Arial';
            daysHeader.forEach((d, i) => {
                ctx.fillStyle = i === 0 ? '#d00' : '#333'; ctx.fillText(d, 60 + i * 65, 170);
            });
            let firstDayIndex = monthIndex === 0 ? 4 : 0;
            let totalDays = monthIndex === 0 ? 31 : 28;
            let date = 1;
            ctx.font = 'bold 28px Arial';
            for (let row = 0; row < 6; row++) {
                for (let col = 0; col < 7; col++) {
                    const index = row * 7 + col;
                    if (index >= firstDayIndex && date <= totalDays) {
                        const x = 60 + col * 65; const y = 230 + row * 50;
                        if (monthIndex === 0 && date === 25) {
                            ctx.strokeStyle = 'red'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(x, y - 10, 25, 0, Math.PI * 2); ctx.stroke();
                            ctx.fillStyle = 'red'; ctx.font = 'bold 14px Arial'; ctx.fillText("Seminar", x, y + 30);
                            ctx.font = 'bold 28px Arial'; 
                        }
                        ctx.fillStyle = col === 0 ? '#d00' : '#333'; ctx.textAlign = 'center';
                        ctx.fillText(date.toString(), x, y); date++;
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace; return tex;
        }

        function updateMathLogic() {
            correctAnswer = (slantHeight * 2 + baseDepth) * width;
            const guideHTML = `
                <div style="font-size:14px; line-height:1.6;">
                    - Chu vi ƒë√°y: <span class="math">C = ${slantHeight} + ${slantHeight} + ${baseDepth} = ${slantHeight*2 + baseDepth} cm</span><br>
                    - Di·ªán t√≠ch xung quanh: <span class="math">S = C √ó ${width} = ${correctAnswer} cm¬≤</span>
                </div>`;
            document.getElementById('guideContent').innerHTML = guideHTML;
        }

        document.getElementById('checkBtn').onclick = () => {
            const val = parseFloat(document.getElementById('userAnswer').value);
            const feedback = document.getElementById('feedback');
            if (Math.abs(val - correctAnswer) < 1) {
                feedback.innerHTML = "Ch√≠nh x√°c! Ch√∫c m·ª´ng b·∫°n! üéâ";
                feedback.className = "feedback correct";
            } else {
                feedback.innerHTML = "Ch∆∞a ƒë√∫ng, h√£y nh√¨n k·ªπ c√°c s·ªë ƒëo tr√™n h√¨nh.";
                feedback.className = "feedback incorrect";
            }
        };

        document.getElementById('guideBtn').onclick = () => {
            const g = document.getElementById('guideContent');
            g.style.display = g.style.display === 'block' ? 'none' : 'block';
        };

        document.getElementById('newExerciseBtn').onclick = () => {
            const f = document.getElementById('customForm');
            f.style.display = f.style.display === 'block' ? 'none' : 'block';
        };

        document.getElementById('applyCustomBtn').onclick = () => {
            slantHeight = parseFloat(document.getElementById('inputSlant').value);
            baseDepth = parseFloat(document.getElementById('inputBase').value);
            width = parseFloat(document.getElementById('inputLength').value);
            rebuildModel();
            updateMathLogic();
            document.getElementById('customForm').style.display = 'none';
        };

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>