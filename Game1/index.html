<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game: Th·ª£ SƒÉn L·ªÅu Tr·∫°i</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #87CEEB; /* M√†u tr·ªùi */
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        /* Header Stats */
        .header {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            pointer-events: auto;
        }
        .stat-box {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.1em;
        }
        .level-badge {
            background: #e67e22;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        /* Quest Box */
        .quest-container {
            align-self: flex-end; 
            margin-right: 30px;
            margin-bottom: 30px;
            
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 400px;
            pointer-events: auto;
            border: 3px solid #3498db;
            transition: transform 0.3s;
            max-height: 70vh; 
            overflow-y: auto; 
        }
        .quest-container.shake {
            animation: shake 0.5s;
            border-color: #e74c3c;
        }
        
        h2 { margin: 0 0 10px 0; color: #2980b9; font-size: 1.5em; }
        .param-list {
            background: #f1f8ff;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: left;
            font-family: monospace;
            font-size: 1.1em;
        }
        .input-area {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        input[type="number"] {
            flex: 1;
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            font-size: 1.1em;
            outline: none;
        }
        input[type="number"]:focus { border-color: #3498db; }
        
        button.submit-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.2s;
        }
        button.submit-btn:hover { background: #2ecc71; }

        button.retry-btn {
            background: #e67e22;
            width: 100%;
            margin-top: 10px;
            display: none; /* ·∫®n m·∫∑c ƒë·ªãnh */
        }
        button.retry-btn:hover { background: #d35400; }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 100;
            pointer-events: auto;
        }
        .big-btn {
            background: #e67e22;
            color: white;
            font-size: 1.5em;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4);
            transition: transform 0.2s;
        }
        .big-btn:hover { transform: scale(1.05); }

        /* Feedback Modal */
        #feedback-msg {
            color: #e74c3c;
            font-weight: bold;
            margin-top: 10px;
            min-height: 20px;
        }
        
        /* Solution Box Styles */
        .solution-box {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: left;
            font-size: 0.95em;
            display: none;
        }
        .solution-title {
            font-weight: bold;
            border-bottom: 1px dashed #856404;
            padding-bottom: 5px;
            margin-bottom: 10px;
            display: block;
        }
        .solution-step {
            margin-bottom: 8px;
        }
        .highlight-val {
            color: #d35400;
            font-weight: bold;
        }

        .hint-text {
            color: #7f8c8d;
            font-size: 0.9em;
            font-style: italic;
            margin-top: 5px;
            display: none;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        #instructions {
            position: absolute;
            top: 60px; /* D∆∞·ªõi header */
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            color: #555;
            pointer-events: auto; /* Cho ph√©p click n·∫øu c·∫ßn */
        }
    </style>
</head>
<body>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1 style="font-size: 3em; margin-bottom: 10px; text-shadow: 2px 2px #333;">üé™ X√¢y D·ª±ng L·ªÅu Tr·∫°i</h1>
        <p style="font-size: 1.2em; max-width: 600px; text-align: center;">
            Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi x∆∞·ªüng s·∫£n xu·∫•t l·ªÅu!<br>
            Kh√°ch h√†ng s·∫Ω g·ª≠i y√™u c·∫ßu k√≠ch th∆∞·ªõc. <br>
            Nhi·ªám v·ª• c·ªßa b·∫°n l√† t√≠nh to√°n ch√≠nh x√°c ƒë·ªÉ c·∫Øt v·∫£i v√† l·∫Øp ƒëi·ªÅu h√≤a.
        </p>
        <button class="big-btn" onclick="startGame()">B·∫Øt ƒê·∫ßu L√†m Vi·ªác</button>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container" style="width:100%; height:100vh;"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div class="header">
            <div class="stat-box">‚≠ê ƒêi·ªÉm: <span id="score">0</span></div>
            <div class="level-badge" id="level-display">Level 1: T√≠nh Di·ªán T√≠ch V·∫£i</div>
            <div class="stat-box">ƒê∆°n h√†ng: <span id="q-num">1</span>/5</div>
        </div>

        <div id="instructions">
            üñ±Ô∏è <b>Chu·ªôt tr√°i:</b> Xoay | üñ±Ô∏è <b>Chu·ªôt ph·∫£i:</b> K√©o m·∫∑t ph·∫≥ng | üìú <b>LƒÉn chu·ªôt:</b> Thu/Ph√≥ng
        </div>

        <div class="quest-container" id="quest-box">
            <h2 id="quest-title">ƒê∆°n h√†ng s·ªë 1</h2>
            <p id="quest-desc">Kh√°ch c·∫ßn m·ªôt chi·∫øc l·ªÅu h√¨nh lƒÉng tr·ª• tam gi√°c.</p>
            
            <div class="param-list" id="params">
                <!-- Parameters will be injected here -->
            </div>

            <p style="font-weight:bold; margin-bottom:5px;" id="question-text">T√≠nh di·ªán t√≠ch to√†n ph·∫ßn?</p>
            <p style="font-size:0.85em; color:#666; margin-top:0;">(K·∫øt qu·∫£ l√†m tr√≤n 2 ch·ªØ s·ªë th·∫≠p ph√¢n)</p>

            <div class="input-area">
                <input type="number" id="user-answer" placeholder="Nh·∫≠p k·∫øt qu·∫£..." step="0.01">
                <button class="submit-btn" onclick="checkAnswer()">G·ª≠i H√†ng</button>
            </div>
            
            <div id="feedback-msg"></div>
            
            <!-- Solution Container -->
            <div id="solution-box" class="solution-box">
                <span class="solution-title">üí° L·ªùi gi·∫£i chi ti·∫øt (cho s·ªë li·ªáu c≈©):</span>
                <div id="solution-content"></div>
            </div>

            <div id="hint-text" class="hint-text"></div>
            
            <!-- N√∫t S·ª≠a L·ªói / L√†m L·∫°i (V·ªõi s·ªë li·ªáu m·ªõi) -->
            <button id="retry-btn" class="submit-btn retry-btn" onclick="retryLevel()">üîÑ Th·ª≠ L·∫°i (S·ªë li·ªáu m·ªõi)</button>
            
            <!-- N√∫t Qua M√†n -->
            <button id="next-btn" class="submit-btn" style="background:#3498db; width:100%; margin-top:10px; display:none;" onclick="nextLevel()">ƒê∆°n h√†ng ti·∫øp theo ‚ûù</button>
        </div>
    </div>

    <script>
        // --- GAME LOGIC ---
        let currentLevel = 1;
        let score = 0;
        let questionCount = 1;
        let currentParams = {};
        let isGameActive = false;
        
        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            isGameActive = true;
            score = 0;
            currentLevel = 1;
            questionCount = 1;
            updateUI();
            generateQuestion();
        }

        function generateQuestion() {
            // Reset UI
            document.getElementById('user-answer').value = '';
            document.getElementById('feedback-msg').textContent = '';
            document.getElementById('solution-box').style.display = 'none'; 
            document.getElementById('hint-text').style.display = 'none';
            document.getElementById('next-btn').style.display = 'none';
            document.getElementById('retry-btn').style.display = 'none'; 
            document.querySelector('.input-area').style.display = 'flex';
            document.getElementById('quest-box').classList.remove('shake');
            
            // Random parameters
            const a = Math.floor(Math.random() * 4) + 2; 
            const h_tri = Math.floor(Math.random() * 3) + 2; 
            const L = Math.floor(Math.random() * 5) + 3; 
            
            // Calculate raw side edge
            const sideRaw = Math.sqrt(h_tri*h_tri + (a/2)*(a/2));
            const displayedSide = parseFloat(sideRaw.toFixed(2));

            currentParams = { a, h_tri, L, displayedSide };

            // Update 3D Model
            updateTentMesh(a, h_tri, L);

            // Level logic
            if (questionCount > 3) currentLevel = 2;
            
            const paramsDiv = document.getElementById('params');
            paramsDiv.innerHTML = `
                ƒê√°y tam gi√°c (a) = ${a} m<br>
                Cao tam gi√°c (h) = ${h_tri} m<br>
                Chi·ªÅu d√†i l·ªÅu (L) = ${L} m<br>
                <b style="color:#e67e22">C·∫°nh b√™n (c) = ${displayedSide} m</b>
            `;

            const qText = document.getElementById('question-text');
            const hintDiv = document.getElementById('hint-text');

            if (currentLevel === 1) {
                document.getElementById('level-display').textContent = "Level 1: Th·ª£ May V·∫£i";
                document.getElementById('level-display').style.background = "#e67e22";
                
                qText.textContent = "T√≠nh di·ªán t√≠ch to√†n ph·∫ßn c·ªßa l·ªÅu (g·ªìm s√†n + c·ª≠a + m√°i)?";
                
                // Calc based on displayed values
                const pBase = a + 2 * displayedSide; 
                const sLateral = pBase * L;
                const sBase = 0.5 * a * h_tri;
                const totalArea = sLateral + 2 * sBase;
                
                currentParams.answer = parseFloat(totalArea.toFixed(2));

                currentParams.solutionHTML = `
                    <div class="solution-step">1. <b>Chu vi ƒë√°y tam gi√°c:</b><br>
                    (D√πng c·∫°nh b√™n ƒë√£ cho: ${displayedSide})<br>
                    P = ${a} + 2 √ó ${displayedSide} = <span class="highlight-val">${pBase.toFixed(2)}</span> m</div>
                    
                    <div class="solution-step">2. <b>Di·ªán t√≠ch xung quanh:</b><br>
                    S<sub>xq</sub> = P √ó L = ${pBase.toFixed(2)} √ó ${L} = <span class="highlight-val">${sLateral.toFixed(2)}</span> m¬≤</div>
                    
                    <div class="solution-step">3. <b>Di·ªán t√≠ch 2 m·∫∑t ƒë√°y (c·ª≠a):</b><br>
                    2 √ó S<sub>ƒë√°y</sub> = 2 √ó (¬Ω √ó ${a} √ó ${h_tri}) = <span class="highlight-val">${(2*sBase).toFixed(2)}</span> m¬≤</div>
                    
                    <div class="solution-step">4. <b>T·ªïng di·ªán t√≠ch:</b><br>
                    S<sub>tp</sub> = ${sLateral.toFixed(2)} + ${(2*sBase).toFixed(2)} = <span class="highlight-val">${totalArea.toFixed(2)}</span> m¬≤</div>
                `;
                
                hintDiv.innerHTML = `G·ª£i √Ω: S<sub>tp</sub> = S<sub>xq</sub> + 2.S<sub>ƒë√°y</sub>`;

            } else {
                document.getElementById('level-display').textContent = "Level 2: K·ªπ S∆∞ ƒêi·ªÅu H√≤a";
                document.getElementById('level-display').style.background = "#8e44ad";
                
                qText.textContent = "T√≠nh th·ªÉ t√≠ch kh√¥ng kh√≠ b√™n trong l·ªÅu?";
                
                const sBase = 0.5 * a * h_tri;
                const volume = sBase * L;
                currentParams.answer = parseFloat(volume.toFixed(2));
                
                currentParams.solutionHTML = `
                    <div class="solution-step">1. <b>Di·ªán t√≠ch m·∫∑t ƒë√°y (tam gi√°c):</b><br>
                    S<sub>ƒë√°y</sub> = ¬Ω √ó ${a} √ó ${h_tri} = <span class="highlight-val">${sBase.toFixed(2)}</span> m¬≤</div>
                    
                    <div class="solution-step">2. <b>Th·ªÉ t√≠ch kh√¥ng kh√≠:</b><br>
                    V = S<sub>ƒë√°y</sub> √ó L = ${sBase.toFixed(2)} √ó ${L} = <span class="highlight-val">${volume.toFixed(2)}</span> m¬≥</div>
                `;

                hintDiv.innerHTML = `G·ª£i √Ω: V = S<sub>ƒë√°y</sub> . Chi·ªÅu_d√†i_l·ªÅu`;
            }

            updateUI();
        }

        function checkAnswer() {
            const userVal = parseFloat(document.getElementById('user-answer').value);
            const correctVal = currentParams.answer;
            
            if (isNaN(userVal)) return;

            if (Math.abs(userVal - correctVal) <= 0.1) {
                // CORRECT
                score += 10;
                confetti({
                    particleCount: 100,
                    spread: 70,
                    origin: { y: 0.6 }
                });
                document.getElementById('feedback-msg').textContent = "Ch√≠nh x√°c! L·ªÅu r·∫•t v·ªØng ch·∫Øc.";
                document.getElementById('feedback-msg').style.color = "#27ae60";
                document.querySelector('.input-area').style.display = 'none';
                document.getElementById('next-btn').style.display = 'block';
                document.getElementById('retry-btn').style.display = 'none';
                
                bounceTent();

            } else {
                // WRONG - HI·ªÇN TH·ªä L·ªúI GI·∫¢I & N√öT L√ÄM L·∫†I
                document.getElementById('feedback-msg').innerHTML = `Sai r·ªìi! H√£y xem l·ªùi gi·∫£i b√™n d∆∞·ªõi r·ªìi th·ª≠ l·∫°i nh√©.`;
                document.getElementById('feedback-msg').style.color = "#c0392b";
                
                const solBox = document.getElementById('solution-box');
                const solContent = document.getElementById('solution-content');
                solContent.innerHTML = currentParams.solutionHTML;
                solBox.style.display = 'block';
                
                // ·∫®n input, hi·ªán n√∫t L√†m L·∫°i
                document.querySelector('.input-area').style.display = 'none';
                document.getElementById('retry-btn').style.display = 'block'; // Hi·ªán n√∫t l√†m l·∫°i
                document.getElementById('next-btn').style.display = 'none';

                document.getElementById('quest-box').classList.add('shake');
                setTimeout(() => document.getElementById('quest-box').classList.remove('shake'), 500);
                
                collapseTent();
            }
            updateUI();
        }

        function retryLevel() {
            // KH√îI PH·ª§C TR·∫†NG TH√ÅI L·ªÄU
            resetTentPosition();
            const tent = tentGroup.getObjectByName("tentMesh");
            if(tent) tent.material.color.setHex(0xe67e22);

            // T·∫†O S·ªê LI·ªÜU M·ªöI (Gi·ªØ nguy√™n Question Count)
            generateQuestion();
        }

        function nextLevel() {
            questionCount++;
            if (questionCount > 5) {
                alert(`Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh kh√≥a hu·∫•n luy·ªán v·ªõi s·ªë ƒëi·ªÉm: ${score}`);
                startGame(); // Restart
            } else {
                resetTentPosition(); 
                generateQuestion();
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('q-num').textContent = questionCount;
            document.getElementById('quest-title').textContent = `ƒê∆°n h√†ng s·ªë ${questionCount}`;
        }


        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        
        // Ground (Green Grass)
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x7CFC00 }); // M√†u c·ªè t∆∞∆°i
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        scene.add(ground);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 7, 12); 
        camera.lookAt(-2, 1, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        // Tent Group - ƒê∆ØA L√äN TR∆Ø·ªöC khi g·ªçi addEnvironment ƒë·ªÉ tr√°nh l·ªói n·∫øu c√≥ t∆∞∆°ng t√°c
        let tentGroup = new THREE.Group();
        scene.add(tentGroup);

        // Environment Group (Trees, Flowers, River, Mountains, Animals, Butterflies)
        const envGroup = new THREE.Group();
        scene.add(envGroup);
        
        // M·∫£ng ch·ª©a c√°c ƒë·ªông v·∫≠t ƒë·ªÉ c·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông
        let animals = [];
        // M·∫£ng ch·ª©a c√°c con b∆∞·ªõm
        let butterflies = [];

        addEnvironment(); // Sinh c·∫£nh quan
        
        updateTentMesh(3, 2.5, 5);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001; // Th·ªùi gian t√≠nh b·∫±ng gi√¢y

            if (isGameActive) {
                tentGroup.rotation.y += 0.002;
            }
            
            // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông cho ƒë·ªông v·∫≠t
            animals.forEach(animal => {
                if (animal.userData.type === 'rabbit') {
                    // Nh·∫£y l√™n xu·ªëng
                    animal.position.y = Math.abs(Math.sin(time * animal.userData.hopSpeed * 5)) * animal.userData.hopHeight;
                } else if (animal.userData.type === 'bird') {
                    // M·ªï (peck) - Xoay ƒë·∫ßu nh·∫π
                    const head = animal.children[1]; // Gi·∫£ s·ª≠ ƒë·∫ßu l√† con th·ª© 2
                    if (head) {
                        head.rotation.x = Math.sin(time * animal.userData.peckSpeed * 10) * 0.2;
                    }
                }
            });

            // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông cho b∆∞·ªõm
            butterflies.forEach((b, index) => {
                // Bay l∆∞·ª£n theo qu·ªπ ƒë·∫°o sin/cos
                b.position.x = b.userData.initialPos.x + Math.sin(time * b.userData.speed + index) * b.userData.radius;
                b.position.z = b.userData.initialPos.z + Math.cos(time * b.userData.speed * 0.8 + index) * b.userData.radius;
                b.position.y = b.userData.initialPos.y + Math.sin(time * b.userData.speed * 1.2 + index) * 0.5;
                
                // V·ªó c√°nh
                b.children[0].rotation.y = Math.sin(time * 15 + index) * 0.4; // C√°nh tr√°i
                b.children[1].rotation.y = -Math.sin(time * 15 + index) * 0.4; // C√°nh ph·∫£i

                // H∆∞·ªõng ƒë·∫ßu v·ªÅ ph√≠a di chuy·ªÉn (ƒë·∫°o h√†m c·ªßa v·ªã tr√≠)
                const dx = Math.cos(time * b.userData.speed + index);
                const dz = -Math.sin(time * b.userData.speed * 0.8 + index);
                b.rotation.y = Math.atan2(dx, dz);
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // --- ENVIRONMENT FUNCTIONS ---
        function addEnvironment() {
            // D√£y n√∫i xa
            createMountainRange();
            // Con s√¥ng
            createRiver();
            // C√¢y c·ªëi
            for(let i=0; i<30; i++) createTree();
            // Hoa ƒëa d·∫°ng
            for(let i=0; i<50; i++) createDiverseFlower();
            // ƒê√°
            for(let i=0; i<20; i++) createRock();
            // M√¢y
            for(let i=0; i<8; i++) createCloud();
            // ƒê·ªông v·∫≠t
            for(let i=0; i<5; i++) createAnimal();
            // B∆∞·ªõm
            for(let i=0; i<10; i++) createButterfly();
        }

        function createMountainRange() {
            // T·∫°o m·ªôt d·∫£i n√∫i ·ªü ph√≠a xa (ph√≠a sau l·ªÅu)
            const mountainGeo = new THREE.PlaneGeometry(100, 30, 32, 16);
            
            // Bi·∫øn d·∫°ng ƒë·ªânh ƒë·ªÉ t·∫°o h√¨nh n√∫i (Displacement ƒë∆°n gi·∫£n)
            const posAttribute = mountainGeo.attributes.position;
            for (let i = 0; i < posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                const z = posAttribute.getZ(i);
                
                // T·∫°o ƒë·ªô cao ng·∫´u nhi√™n d·ª±a tr√™n v·ªã tr√≠ x, y (trong kh√¥ng gian plane)
                // S·ª≠ d·ª•ng h√†m sin/cos ƒë·ªÉ t·∫°o s·ª± nh·∫•p nh√¥ t·ª± nhi√™n h∆°n
                let height = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 5 + Math.random() * 2;
                // Gi·∫£m ƒë·ªô cao ·ªü c√°c c·∫°nh ƒë·ªÉ tr√¥ng li·ªÅn m·∫°ch h∆°n v·ªõi n·ªÅn
                height *= Math.max(0, 1 - Math.abs(y) / 15);

                posAttribute.setZ(i, z + height);
            }
            mountainGeo.computeVertexNormals();

            // V·∫≠t li·ªáu n√∫i: Chuy·ªÉn s·∫Øc t·ª´ xanh r√™u (ch√¢n n√∫i) l√™n x√°m ƒë√°/tr·∫Øng tuy·∫øt (ƒë·ªânh n√∫i)
            // S·ª≠ d·ª•ng Vertex Colors cho hi·ªáu ·ª©ng n√†y
            mountainGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(posAttribute.count * 3), 3));
            const colors = mountainGeo.attributes.color;
            for (let i = 0; i < posAttribute.count; i++) {
                const z = posAttribute.getZ(i); // ƒê·ªô cao th·ª±c t·∫ø sau khi bi·∫øn d·∫°ng
                const normalizedHeight = Math.max(0, Math.min(1, z / 10)); // Chu·∫©n h√≥a 0-1
                
                const color = new THREE.Color();
                if (normalizedHeight < 0.3) {
                    color.setHex(0x556B2F); // Dark Olive Green (ch√¢n n√∫i)
                } else if (normalizedHeight < 0.7) {
                    color.setHex(0x808080); // Gray (th√¢n n√∫i ƒë√°)
                } else {
                    color.setHex(0xFFFFFF); // White (ƒë·ªânh n√∫i tuy·∫øt)
                }
                
                colors.setXYZ(i, color.r, color.g, color.b);
            }

            const mountainMat = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.9,
                flatShading: true // T·∫°o phong c√°ch low-poly
            });

            const mountain = new THREE.Mesh(mountainGeo, mountainMat);
            mountain.rotation.x = -Math.PI / 2; // N·∫±m ngang
            mountain.position.set(0, -1, -40); // ƒê·∫∑t ·ªü xa ph√≠a sau
            mountain.scale.set(1, 1, 2); // K√©o d√†i theo tr·ª•c Z ƒë·ªÉ t·∫°o chi·ªÅu s√¢u
            
            envGroup.add(mountain);
        }

        function createRiver() {
            // T·∫°o m·ªôt ƒë∆∞·ªùng cong cho s√¥ng
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-40, 0.1, 20),
                new THREE.Vector3(-20, 0.1, 15),
                new THREE.Vector3(0, 0.1, 25),
                new THREE.Vector3(20, 0.1, 10),
                new THREE.Vector3(40, 0.1, 30)
            ]);
            
            const tubeGeo = new THREE.TubeGeometry(curve, 64, 3, 16, false);
            const riverMat = new THREE.MeshStandardMaterial({
                color: 0x4682B4, // Steel Blue
                transparent: true,
                opacity: 0.7,
                roughness: 0.2,
                metalness: 0.1
            });
            
            const river = new THREE.Mesh(tubeGeo, riverMat);
            // H·∫° th·∫•p xu·ªëng m·ªôt ch√∫t ƒë·ªÉ m·∫∑t n∆∞·ªõc ph·∫≥ng v·ªõi n·ªÅn c·ªè
            river.position.y = -0.15; 
            envGroup.add(river);
        }

        function createTree() {
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
            const trunkMat = new THREE.MeshStandardMaterial({color: 0x8B4513});
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            
            // T√°n l√° ki·ªÉu c√¢y th√¥ng: nhi·ªÅu t·∫ßng h√¨nh n√≥n
            const leavesGroup = new THREE.Group();
            const leavesMat = new THREE.MeshStandardMaterial({color: 0x228B22, flatShading: true});
            
            const layer1 = new THREE.Mesh(new THREE.ConeGeometry(1.5, 2, 8), leavesMat);
            layer1.position.y = 1.5;
            const layer2 = new THREE.Mesh(new THREE.ConeGeometry(1.2, 1.8, 8), leavesMat);
            layer2.position.y = 2.5;
            const layer3 = new THREE.Mesh(new THREE.ConeGeometry(0.9, 1.5, 8), leavesMat);
            layer3.position.y = 3.4;
            
            leavesGroup.add(layer1);
            leavesGroup.add(layer2);
            leavesGroup.add(layer3);

            const tree = new THREE.Group();
            tree.add(trunk);
            tree.add(leavesGroup);

            let x, z;
            do {
                x = (Math.random() - 0.5) * 80; 
                z = (Math.random() - 0.5) * 60;
            } while (Math.sqrt(x*x + z*z) < 10 || (z > 5 && z < 35)); // Tr√°nh l·ªÅu v√† s√¥ng

            tree.position.set(x, 0.75, z); 
            envGroup.add(tree);
        }

        function createDiverseFlower() {
            const type = Math.floor(Math.random() * 3); // 0: Tulip, 1: C√∫c, 2: B·ª•i hoa nh·ªè
            let flowerGroup = new THREE.Group();
            let stem, petals;

            if (type === 0) { // Tulip
                stem = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6), new THREE.MeshBasicMaterial({color: 0x006400}));
                
                const petalColor = Math.random() > 0.5 ? 0xFF69B4 : 0xFF4500; // H·ªìng ho·∫∑c Cam ƒë·ªè
                petals = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.25, 6, 1, true), new THREE.MeshBasicMaterial({color: petalColor, side: THREE.DoubleSide}));
                petals.rotation.x = Math.PI; // √öp ng∆∞·ª£c n√≥n l·∫°i
                petals.position.y = 0.4;
            } else if (type === 1) { // C√∫c (Daisy)
                stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6), new THREE.MeshBasicMaterial({color: 0x006400}));
                
                const center = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), new THREE.MeshBasicMaterial({color: 0xFFFF00})); // Nh·ª•y v√†ng
                center.position.y = 0.3;
                
                petals = new THREE.Group();
                const petalGeo = new THREE.CircleGeometry(0.06, 3);
                const petalMat = new THREE.MeshBasicMaterial({color: 0xFFFFFF, side: THREE.DoubleSide});
                for(let i=0; i<8; i++) {
                    const p = new THREE.Mesh(petalGeo, petalMat);
                    p.position.y = 0.3;
                    p.rotation.x = -Math.PI / 2;
                    p.rotation.z = (i / 8) * Math.PI * 2;
                    p.translateX(0.06);
                    petals.add(p);
                }
                petals.add(center);
            } else { // B·ª•i hoa nh·ªè
                stem = new THREE.Group(); // Kh√¥ng c√≥ th√¢n r√µ r√†ng
                petals = new THREE.Group();
                const colors = [0xFF69B4, 0xFFFF00, 0xADD8E6, 0xEE82EE]; // Nhi·ªÅu m√†u
                for(let i=0; i<5; i++) {
                    const pGeo = new THREE.SphereGeometry(0.06, 4, 4);
                    const pMat = new THREE.MeshBasicMaterial({color: colors[Math.floor(Math.random()*colors.length)]});
                    const p = new THREE.Mesh(pGeo, pMat);
                    p.position.set((Math.random()-0.5)*0.2, Math.random()*0.1 + 0.05, (Math.random()-0.5)*0.2);
                    petals.add(p);
                }
            }

            flowerGroup.add(stem);
            flowerGroup.add(petals);

            let x, z;
            do {
                x = (Math.random() - 0.5) * 60; 
                z = (Math.random() - 0.5) * 50;
            } while (Math.sqrt(x*x + z*z) < 6 || (z > 8 && z < 32)); // Tr√°nh l·ªÅu v√† s√¥ng

            flowerGroup.position.set(x, 0, z);
            envGroup.add(flowerGroup);
        }

        function createRock() {
            const geo = new THREE.DodecahedronGeometry(0.3 + Math.random()*0.3); // K√≠ch th∆∞·ªõc ng·∫´u nhi√™n
            const mat = new THREE.MeshStandardMaterial({color: 0x808080, roughness: 0.8});
            const mesh = new THREE.Mesh(geo, mat);
            
            // Bi·∫øn d·∫°ng ng·∫´u nhi√™n
            mesh.scale.set(1 + Math.random()*0.5, 0.5 + Math.random()*0.3, 1 + Math.random()*0.5);
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            let x, z;
            do {
                x = (Math.random() - 0.5) * 70; 
                z = (Math.random() - 0.5) * 60;
            } while (Math.sqrt(x*x + z*z) < 7);

            mesh.position.set(x, 0.1, z);
            envGroup.add(mesh);
        }

        function createCloud() {
            const geo = new THREE.SphereGeometry(1.5, 8, 8);
            const mat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.7});
            
            const cloud = new THREE.Group();
            // G·ªôp nhi·ªÅu kh·ªëi c·∫ßu l·∫°i th√†nh m√¢y ph·ª©c t·∫°p h∆°n
            const numPuffs = 3 + Math.floor(Math.random() * 3);
            for(let i=0; i<numPuffs; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.set((Math.random()-0.5)*2.5, (Math.random()-0.5)*1, (Math.random()-0.5)*2);
                p.scale.setScalar(0.7 + Math.random()*0.5);
                cloud.add(p);
            }
            
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 60;
            const y = 12 + Math.random() * 8; // Cao ƒë·ªô 12-20m
            
            cloud.position.set(x, y, z);
            
            // Th√™m chuy·ªÉn ƒë·ªông tr√¥i ch·∫≠m cho m√¢y
            cloud.userData = { speed: 0.01 + Math.random()*0.02 };
            
            envGroup.add(cloud);
        }
        
        function createAnimal() {
            const type = Math.random() > 0.5 ? 'rabbit' : 'bird';
            let animalGroup = new THREE.Group();

            if (type === 'rabbit') {
                // Th√¢n
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshStandardMaterial({color: 0xFFFFFF}));
                body.scale.set(1, 0.8, 1.2);
                body.position.y = 0.3;
                // ƒê·∫ßu
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshStandardMaterial({color: 0xFFFFFF}));
                head.position.set(0, 0.5, 0.35);
                // Tai (S·ª≠a CapsuleGeometry -> CylinderGeometry cho r128)
                const earGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
                const ear1 = new THREE.Mesh(earGeo, new THREE.MeshStandardMaterial({color: 0xFFFFFF}));
                ear1.position.set(0.1, 0.8, 0.35); ear1.rotation.x = -0.2;
                const ear2 = ear1.clone();
                ear2.position.set(-0.1, 0.8, 0.35);

                animalGroup.add(body, head, ear1, ear2);
                // Th√™m d·ªØ li·ªáu cho chuy·ªÉn ƒë·ªông
                animalGroup.userData = { type: 'rabbit', hopSpeed: 1 + Math.random(), hopHeight: 0.3 + Math.random() * 0.2 };

            } else { // Bird (ƒë·∫≠u tr√™n m·∫∑t ƒë·∫•t)
                // Th√¢n (S·ª≠a CapsuleGeometry -> CylinderGeometry cho r128)
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.3, 8), new THREE.MeshStandardMaterial({color: 0x4169E1})); // Xanh d∆∞∆°ng
                body.rotation.x = Math.PI / 2;
                body.position.y = 0.25;
                // ƒê·∫ßu
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), new THREE.MeshStandardMaterial({color: 0x4169E1}));
                head.position.set(0, 0.35, 0.25);
                // M·ªè
                const beak = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.1, 8), new THREE.MeshStandardMaterial({color: 0xFFA500})); // Cam
                beak.rotation.x = Math.PI / 2;
                beak.position.set(0, 0.35, 0.4);

                animalGroup.add(body, head, beak);
                // Th√™m d·ªØ li·ªáu cho chuy·ªÉn ƒë·ªông
                animalGroup.userData = { type: 'bird', peckSpeed: 1 + Math.random() };
            }

            let x, z;
            do {
                x = (Math.random() - 0.5) * 50; 
                z = (Math.random() - 0.5) * 50;
            } while (Math.sqrt(x*x + z*z) < 8);

            animalGroup.position.set(x, 0, z);
            animalGroup.rotation.y = Math.random() * Math.PI * 2;
            envGroup.add(animalGroup);
            // Th√™m v√†o m·∫£ng qu·∫£n l√Ω
            animals.push(animalGroup);
        }

        function createButterfly() {
            const butterflyGroup = new THREE.Group();
            
            // T·∫°o h√¨nh d·∫°ng c√°nh b∆∞·ªõm
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.quadraticCurveTo(0.2, 0.2, 0.2, 0.4);
            wingShape.quadraticCurveTo(0.2, 0.6, 0, 0.8);
            wingShape.quadraticCurveTo(-0.2, 0.6, -0.2, 0.4);
            wingShape.quadraticCurveTo(-0.2, 0.2, 0, 0);

            const extrudeSettings = { steps: 1, depth: 0.01, bevelEnabled: false };
            const wingGeo = new THREE.ExtrudeGeometry(wingShape, extrudeSettings);
            
            // M√†u s·∫Øc ng·∫´u nhi√™n
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.5);
            const wingMat = new THREE.MeshStandardMaterial({color: color, side: THREE.DoubleSide});

            // C√°nh tr√°i
            const leftWing = new THREE.Mesh(wingGeo, wingMat);
            leftWing.rotation.x = Math.PI / 2;
            leftWing.position.x = -0.01;
            
            // C√°nh ph·∫£i
            const rightWing = new THREE.Mesh(wingGeo, wingMat);
            rightWing.rotation.x = Math.PI / 2;
            rightWing.rotation.z = Math.PI; // L·∫≠t ng∆∞·ª£c l·∫°i
            rightWing.position.x = 0.01;
            
            butterflyGroup.add(leftWing);
            butterflyGroup.add(rightWing);
            
            // V·ªã tr√≠ ban ƒë·∫ßu ng·∫´u nhi√™n
            let x = (Math.random() - 0.5) * 40;
            let z = (Math.random() - 0.5) * 40;
            let y = 1 + Math.random() * 3;
            butterflyGroup.position.set(x, y, z);
            
            // D·ªØ li·ªáu chuy·ªÉn ƒë·ªông
            butterflyGroup.userData = {
                speed: 0.5 + Math.random() * 0.5,
                radius: 2 + Math.random() * 3,
                initialPos: butterflyGroup.position.clone()
            };
            
            envGroup.add(butterflyGroup);
            butterflies.push(butterflyGroup);
        }

        // --- 3D HELPER FUNCTIONS ---

        function updateTentMesh(a, h, L) {
            while(tentGroup.children.length > 0){ 
                tentGroup.remove(tentGroup.children[0]); 
            }
            tentGroup.rotation.y = -Math.PI / 4; 
            tentGroup.position.set(-3, 0, 0); 
            tentGroup.scale.set(1, 1, 1);

            const shape = new THREE.Shape();
            shape.moveTo(-a/2, 0);
            shape.lineTo(a/2, 0);
            shape.lineTo(0, h);
            shape.lineTo(-a/2, 0);

            const extrudeSettings = {
                steps: 1,
                depth: L,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();
            geometry.translate(0, h/2, 0);

            const material = new THREE.MeshStandardMaterial({ 
                color: 0xe67e22, 
                roughness: 0.9,
                side: THREE.DoubleSide
            });

            const tentMesh = new THREE.Mesh(geometry, material);
            tentMesh.castShadow = true;
            tentMesh.name = "tentMesh";
            tentGroup.add(tentMesh);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x2c3e50, linewidth: 2 }));
            tentGroup.add(line);
        }

        function collapseTent() {
            const tent = tentGroup.getObjectByName("tentMesh");
            if (tent) {
                let s = 1;
                const interval = setInterval(() => {
                    s -= 0.05;
                    if (s <= 0.1) {
                        s = 0.1;
                        clearInterval(interval);
                        tent.material.color.setHex(0xc0392b);
                    }
                    // Gi·ªØ nguy√™n v·ªã tr√≠ X (-3) khi scale
                    tentGroup.scale.set(1, s, 1);
                }, 16);
            }
        }

        function bounceTent() {
            let s = 1;
            let dir = 0.02;
            let count = 0;
            const interval = setInterval(() => {
                s += dir;
                if (s > 1.1) dir = -0.02;
                if (s < 1.0) {
                    dir = 0.02;
                    count++;
                }
                tentGroup.scale.set(s, s, s);
                if (count > 2) {
                    clearInterval(interval);
                    tentGroup.scale.set(1, 1, 1);
                }
            }, 16);
        }

        function resetTentPosition() {
            tentGroup.scale.set(1, 1, 1);
        }

    </script>
</body>
</html>