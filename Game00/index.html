<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Thi√™n C∆° B·∫£ng - K·∫øt ·∫§n (Fixed)</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/@mediapipe/drawing_utils@0.3/drawing_utils.js"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Merriweather:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Merriweather', serif; user-select: none; }
        
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1); z-index: 0;
            opacity: 0.3;
        }
        
        #debug-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none; transform: scaleX(-1);
        }

        /* Theme Tu Ti√™n */
        .glass-panel {
            background: rgba(10, 5, 20, 0.85);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2), inset 0 0 50px rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }

        .title-font { font-family: 'Cinzel Decorative', cursive; letter-spacing: 2px; text-shadow: 0 0 10px #d4af37; }

        /* K·∫øt ·∫§n UI */
        .mudra-container {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50; pointer-events: none;
        }

        .mudra-circle {
            width: 250px; height: 250px;
            border: 4px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            position: relative;
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .mudra-circle.active {
            border-color: #00ffff;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.3);
        }

        .finger-count-display {
            font-size: 120px; font-weight: 900; color: #fff;
            text-shadow: 0 0 20px #00ffff;
            z-index: 2;
        }

        /* N√∫t ch·ªçn s·ªë l∆∞·ª£ng */
        .rune-card {
            background: rgba(0,0,0,0.5); border: 1px solid #444; color: #666;
            width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;
            font-size: 24px; font-weight: bold; border-radius: 8px;
            transition: all 0.3s;
        }
        .rune-card.highlight {
            background: rgba(0, 255, 255, 0.2); border-color: #00ffff; color: #00ffff;
            transform: scale(1.2) translateY(-10px);
            box-shadow: 0 0 15px cyan;
        }

        /* Status Panel */
        .status-panel {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 15px;
            padding: 10px 30px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            background: rgba(0, 20, 40, 0.9);
            border-radius: 50px;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            z-index: 60;
            pointer-events: none;
            transition: all 0.3s;
        }
        .status-dot {
            width: 12px; height: 12px; border-radius: 50%;
            background: #333; box-shadow: 0 0 5px #333;
        }
        .status-dot.active { background: #00ff00; box-shadow: 0 0 10px #00ff00; }

        /* Countdown Overlay */
        .countdown-overlay {
            position: fixed; inset: 0; z-index: 100;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            animation: fadeIn 0.3s;
        }
        .countdown-number {
            font-size: 250px; font-weight: 900; color: #ffd700;
            text-shadow: 0 0 50px #ff0000, 0 0 100px #ff0000;
            animation: heartBeat 1s infinite;
        }
        .countdown-label {
            font-size: 30px; color: #00ffff; margin-top: -20px;
            text-transform: uppercase; letter-spacing: 5px;
        }

        .winner-card {
            background: rgba(20, 0, 0, 0.9); border: 2px solid gold;
            box-shadow: 0 0 30px gold;
            animation: floatItem 3s ease-in-out infinite;
        }
        @keyframes floatItem { 0%, 100% {transform: translateY(0px);} 50% {transform: translateY(-10px);} }

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- √ÇM THANH ---
        const playSound = (type) => {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const audioCtx = new AudioContext();
                const osc = audioCtx.createOscillator(); 
                const gain = audioCtx.createGain();
                const now = audioCtx.currentTime;
                
                osc.connect(gain); gain.connect(audioCtx.destination);
                
                if(type === 'charge') {
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(400, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'tick') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'lock') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                } else if (type === 'win') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523.25, now);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
                    osc.start(now); osc.stop(now + 2.0);
                }
            } catch(e) { console.warn("Audio error", e); }
        };

        // --- 3D SCENE ---
        const ThreeScene = ({ studentList, isSpinning }) => {
            const containerRef = useRef(null);
            const sceneRef = useRef({ scene: null, camera: null, renderer: null, group: null });

            useEffect(() => {
                if(!containerRef.current) return;
                const w = window.innerWidth;
                const h = window.innerHeight;
                const scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050505, 0.05);

                const camera = new THREE.PerspectiveCamera(75, w/h, 0.1, 100);
                camera.position.z = 9;

                const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(w, h);
                containerRef.current.innerHTML = '';
                containerRef.current.appendChild(renderer.domElement);

                for(let i=0; i<60; i++) {
                    const geo = new THREE.TetrahedronGeometry(0.2);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set((Math.random()-0.5)*25, (Math.random()-0.5)*25, (Math.random()-0.5)*10);
                    scene.add(mesh);
                }

                const group = new THREE.Group();
                scene.add(group);
                sceneRef.current = { scene, camera, renderer, group };

                const animate = () => {
                    requestAnimationFrame(animate);
                    if(group) {
                        group.rotation.y += isSpinning ? 0.4 : 0.002;
                    }
                    renderer.render(scene, camera);
                };
                animate();

                const handleResize = () => {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.aspect = window.innerWidth/window.innerHeight;
                    camera.updateProjectionMatrix();
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            useEffect(() => {
                const { group } = sceneRef.current;
                if(!group) return;
                while(group.children.length > 0) group.remove(group.children[0]); 

                studentList.forEach((name, i) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 1024; canvas.height = 256;
                    ctx.font = 'bold 70px "Merriweather", serif';
                    ctx.fillStyle = '#ffd700';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#d63384'; ctx.shadowBlur = 15;
                    ctx.fillText(name, 512, 128);
                    const texture = new THREE.CanvasTexture(canvas);
                    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
                    sprite.scale.set(6, 1.5, 1);
                    const angle = (i / studentList.length) * Math.PI * 2;
                    const r = 11;
                    sprite.position.set(Math.cos(angle)*r, (Math.random()-0.5)*8, Math.sin(angle)*r);
                    group.add(sprite);
                });
            }, [studentList]);

            return <div ref={containerRef} className="absolute inset-0 z-0" />;
        };

        function App() {
            // Data & State
            const [studentList, setStudentList] = useState([
                "Nguy·ªÖn V≈© Thu An", "Tr·∫ßn Ph√∫c An", "Nguy·ªÖn Ng·ªçc Th·ª•y Anh", "Nguy·ªÖn Vi·ªát Anh", 
                "Ph·∫°m Di·ªáu Anh", "Phan Nh·∫≠t √Çn", "V≈© Y·∫øn Chi", "H√πng C√¥ng Danh", "ƒê√†o Minh D≈©ng", 
                "Nguy·ªÖn L√™ Tr·∫°ch ƒê√¥ng", "Phan Ng·ªçc Khoa", "Nguy·ªÖn L√™ Minh Kh√¥i", "T·∫° Tu·∫•n Ki·ªát", 
                "ƒêinh Phan Thi√™n Kim", "Ng√¥ B·∫£o T√∫ Linh", "Nguy·ªÖn Tr·∫ßn Linh Ng√¢n", "V≈© B·∫£o Ng√¢n", 
                "Nguy·ªÖn Ph√∫c Kh√¥i Nguy√™n", "ƒê·ªó Kh·∫Øc Minh Nh·∫≠t", "L√™ Ng·ªçc An Nhi√™n", "Tr·∫ßn Quang Ninh", 
                "Nguy·ªÖn H√† Minh Ph√°t", "ƒê·ªó Ho√†ng Qu√¢n", "Nguy·ªÖn Th·ªã Minh T√¢m", "Tr·∫ßn Ph·∫°m Qu·ªëc Th·∫Øng", 
                "Phan Ti·∫øn Th·ªãnh", "T√¥ Vƒ©nh Th·ª•y", "Tr·∫ßn L√™ Gia Tu·ªá", "Tr·∫ßn H·ªØu Vi·ªát", "Ph√≠ Ng·ªçc Kh√°nh Vy"
            ]);
            
            const [appState, setAppState] = useState("INIT");
            const [isSpinning, setIsSpinning] = useState(false);
            const [winners, setWinners] = useState([]);
            const [useCamera, setUseCamera] = useState(true);

            const [detectedFingers, setDetectedFingers] = useState(0);
            const [chargeProgress, setChargeProgress] = useState(0);
            const [liveFingers, setLiveFingers] = useState(null); 
            const [countdown, setCountdown] = useState(null);
            
            const videoRef = useRef(null);
            const debugCanvasRef = useRef(null); 

            // LOGIC REF: Ch·ª©a tr·∫°ng th√°i "s·ªëng" ƒë·ªÉ tr√°nh Stale Closure trong Loop
            const logicRef = useRef({ 
                lastFingerCount: 0, 
                holdStartTime: 0, 
                isProcessing: false,
                requiredHoldTime: 1000, // GI·∫¢M XU·ªêNG 1 GI√ÇY CHO D·ªÑ CH·ªåN
                // Flags ƒë·ªìng b·ªô
                isSpinning: false,
                hasWinners: false,
                isCountingDown: false
            });

            // ƒê·ªìng b·ªô State React v√†o Logic Ref
            useEffect(() => {
                logicRef.current.isSpinning = isSpinning;
                logicRef.current.hasWinners = winners.length > 0;
                logicRef.current.isCountingDown = countdown !== null;
            }, [isSpinning, winners, countdown]);

            // --- CAMERA SETUP ---
            const startSystem = async (enableCam) => {
                setAppState("LOADING");
                setUseCamera(enableCam);

                try {
                    if (enableCam) {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            await videoRef.current.play();
                        }
                        
                        if (window.Hands) {
                            const hands = new window.Hands({locateFile: (f) => `https://unpkg.com/@mediapipe/hands@0.4.1675469240/${f}`});
                            hands.setOptions({
                                maxNumHands: 1, 
                                minDetectionConfidence: 0.5, 
                                minTrackingConfidence: 0.5,
                                modelComplexity: 1
                            });
                            hands.onResults(onHandResults);
                            
                            const processVideo = async () => {
                                if (appState === "ERROR") return;
                                if (videoRef.current && videoRef.current.readyState >= 2 && !logicRef.current.isProcessing) {
                                    logicRef.current.isProcessing = true;
                                    await hands.send({image: videoRef.current});
                                    logicRef.current.isProcessing = false;
                                }
                                requestAnimationFrame(processVideo);
                            };
                            processVideo();
                        }
                    }
                    setAppState("READY");
                } catch (err) {
                    console.error(err);
                    setUseCamera(false);
                    setAppState("READY");
                }
            };

            const countExtendedFingers = (landmarks) => {
                let count = 0;
                const distSq = (p1, p2) => Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
                const wrist = landmarks[0];

                // 4 Ng√≥n d√†i
                const fingerIndices = [
                    {tip: 8, pip: 6},   // Index
                    {tip: 12, pip: 10}, // Middle
                    {tip: 16, pip: 14}, // Ring
                    {tip: 20, pip: 18}  // Pinky
                ];
                fingerIndices.forEach(finger => {
                    if (distSq(landmarks[finger.tip], wrist) > distSq(landmarks[finger.pip], wrist)) {
                        count++;
                    }
                });

                // Ng√≥n c√°i (Thumb)
                const thumbTip = landmarks[4];
                const thumbIP = landmarks[3];
                const pinkyMCP = landmarks[17];
                // So s√°nh kho·∫£ng c√°ch t·ªõi g·ªëc ng√≥n √∫t ƒë·ªÉ x√°c ƒë·ªãnh m·ªü/ƒë√≥ng
                if (distSq(thumbTip, pinkyMCP) > distSq(thumbIP, pinkyMCP)) {
                    count++;
                }

                return count;
            };

            const drawDebugSkeleton = (landmarks) => {
                const canvas = debugCanvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!landmarks) return;
                if (videoRef.current) {
                    canvas.width = videoRef.current.videoWidth;
                    canvas.height = videoRef.current.videoHeight;
                }
                ctx.fillStyle = '#00ffff';
                landmarks.forEach(lm => {
                    ctx.beginPath();
                    ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 5, 0, 2 * Math.PI);
                    ctx.fill();
                });
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                const connections = [
                    [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
                    [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
                    [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
                ];
                connections.forEach(([i, j]) => {
                    const p1 = landmarks[i];
                    const p2 = landmarks[j];
                    ctx.beginPath();
                    ctx.moveTo(p1.x * canvas.width, p1.y * canvas.height);
                    ctx.lineTo(p2.x * canvas.width, p2.y * canvas.height);
                    ctx.stroke();
                });
            };

            const onHandResults = (results) => {
                // Ki·ªÉm tra tr·∫°ng th√°i game qua Ref (tr√°nh Stale Closure)
                if (logicRef.current.isSpinning || logicRef.current.hasWinners || logicRef.current.isCountingDown) {
                    // N·∫øu ƒëang b·∫≠n, x√≥a canvas debug v√† return lu√¥n
                    const canvas = debugCanvasRef.current;
                    if(canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }

                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    setLiveFingers(null); 
                    resetCharge();
                    const canvas = debugCanvasRef.current;
                    if(canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }
                
                const lm = results.multiHandLandmarks[0];
                drawDebugSkeleton(lm); 
                
                const fingers = countExtendedFingers(lm);
                setLiveFingers(fingers); 
                processGesture(fingers);
            };

            const resetCharge = () => {
                setDetectedFingers(0);
                setChargeProgress(0);
                logicRef.current.lastFingerCount = 0;
                logicRef.current.holdStartTime = 0;
            };

            const processGesture = (fingers) => {
                const now = Date.now();
                
                if (fingers === 0 || fingers > 5) {
                    resetCharge();
                    return;
                }

                if (fingers !== logicRef.current.lastFingerCount) {
                    // S·ªë ng√≥n thay ƒë·ªïi -> Reset
                    logicRef.current.lastFingerCount = fingers;
                    logicRef.current.holdStartTime = now;
                    setDetectedFingers(fingers);
                    setChargeProgress(0);
                    playSound('charge'); 
                } else {
                    // S·ªë ng√≥n ·ªïn ƒë·ªãnh -> T√≠nh th·ªùi gian gi·ªØ
                    const elapsed = now - logicRef.current.holdStartTime;
                    
                    // N·∫øu holdStartTime b·ªã reset v·ªÅ 0 do logic n√†o ƒë√≥, set l·∫°i ngay
                    if (logicRef.current.holdStartTime === 0) {
                        logicRef.current.holdStartTime = now;
                        return;
                    }

                    const progress = Math.min((elapsed / logicRef.current.requiredHoldTime) * 100, 100);
                    setChargeProgress(progress);

                    if (progress >= 100) {
                        // CH·ªêT!
                        startCountdown(fingers);
                        resetCharge();
                        // Reset lu√¥n detected ƒë·ªÉ ·∫©n UI k·∫øt ·∫•n
                        setDetectedFingers(0);
                    }
                }
            };

            // H√†m b·∫Øt ƒë·∫ßu ƒë·∫øm ng∆∞·ª£c
            const startCountdown = (count) => {
                // ƒê√°nh d·∫•u tr·∫°ng th√°i ngay l·∫≠p t·ª©c
                logicRef.current.isCountingDown = true;
                setCountdown(3);
                playSound('tick');
                
                let val = 3;
                const timer = setInterval(() => {
                    val--;
                    if (val > 0) {
                        setCountdown(val);
                        playSound('tick');
                    } else {
                        clearInterval(timer);
                        setCountdown(null);
                        // Trigger quay
                        triggerGift(count);
                    }
                }, 1000);
            };

            const triggerGift = (count) => {
                if(studentList.length < count) { 
                    alert("Kh√¥ng ƒë·ªß ƒë·∫°o h·ªØu!"); 
                    logicRef.current.isCountingDown = false; // Reset flag n·∫øu l·ªói
                    return; 
                }
                
                playSound('lock');
                setIsSpinning(true);
                // Flag isSpinning s·∫Ω ƒë∆∞·ª£c c·∫≠p nh·∫≠t qua useEffect
                
                setTimeout(() => {
                    const pool = [...studentList];
                    const selected = [];
                    for(let i=0; i<count; i++) {
                        const idx = Math.floor(Math.random() * pool.length);
                        selected.push(pool[idx]); pool.splice(idx, 1);
                    }
                    setWinners(selected);
                    setIsSpinning(false);
                    playSound('win');
                }, 2500); 
            };

            return (
                <div className="w-full h-full relative">
                    {useCamera && <video ref={videoRef} playsInline muted id="input-video"></video>}
                    {useCamera && <canvas ref={debugCanvasRef} id="debug-canvas"></canvas>}
                    
                    <ThreeScene studentList={studentList} isSpinning={isSpinning} />

                    {/* UI LAYER */}
                    <div className="absolute inset-0 z-50 pointer-events-none flex flex-col items-center justify-center p-4">
                        
                        {/* HEADER */}
                        <div className="absolute top-0 w-full p-4 flex justify-between items-start pointer-events-none">
                            <div className="glass-panel px-6 py-2 pointer-events-auto">
                                <h1 className="text-3xl title-font text-yellow-500">Thi√™n C∆° B·∫£ng</h1>
                                <p className="text-sm text-cyan-200">T·ªïng: {studentList.length} ƒê·∫°o H·ªØu</p>
                            </div>
                        </div>

                        {/* STATUS PANEL */}
                        {appState === "READY" && !isSpinning && winners.length === 0 && countdown === null && useCamera && (
                            <div className="status-panel animate__animated animate__fadeInDown">
                                <div className={`status-dot ${liveFingers !== null ? 'active' : ''}`}></div>
                                <div className="text-white font-bold text-lg font-mono">
                                    {liveFingers !== null ? (
                                        <span className="text-cyan-300">ƒê√É TH·∫§Y: <span className="text-2xl text-yellow-400">{liveFingers}</span> NG√ìN</span>
                                    ) : (
                                        <span className="text-gray-400 italic">H√£y gi∆° tay tr∆∞·ªõc Camera...</span>
                                    )}
                                </div>
                            </div>
                        )}

                        {/* V√íNG K·∫æT ·∫§N (Ch·ªâ hi·ªán khi ƒëang gi·ªØ ·ªïn ƒë·ªãnh 1 s·ªë > 0) */}
                        {appState === "READY" && !isSpinning && winners.length === 0 && countdown === null && useCamera && detectedFingers > 0 && (
                            <div className="mudra-container animate__animated animate__zoomIn">
                                <div className={`mudra-circle ${chargeProgress > 0 ? 'active' : ''}`}>
                                    <div className="finger-count-display">{detectedFingers}</div>
                                    <svg className="absolute w-full h-full p-2" viewBox="0 0 100 100">
                                        <circle cx="50" cy="50" r="46" fill="none" stroke="#333" strokeWidth="6" />
                                        <circle 
                                            cx="50" cy="50" r="46" 
                                            fill="none" stroke="#00ffff" strokeWidth="6"
                                            strokeDasharray="289"
                                            strokeDashoffset={289 - (289 * chargeProgress) / 100}
                                            strokeLinecap="round"
                                            style={{transition: 'stroke-dashoffset 0.1s linear'}}
                                        />
                                    </svg>
                                    <div className="absolute -bottom-12 text-cyan-300 font-bold text-shadow whitespace-nowrap bg-black/50 px-3 py-1 rounded">
                                        Gi·ªØ y√™n 1 gi√¢y
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* COUNTDOWN OVERLAY */}
                        {countdown !== null && (
                            <div className="countdown-overlay">
                                <div className="countdown-number">{countdown}</div>
                                <div className="countdown-label">Chu·∫©n b·ªã...</div>
                            </div>
                        )}

                        {/* H∆Ø·ªöNG D·∫™N D∆Ø·ªöI */}
                        {appState === "READY" && !isSpinning && winners.length === 0 && countdown === null && (
                            <div className="absolute bottom-10 flex flex-col items-center animate__animated animate__fadeInUp">
                                <div className="flex gap-4 mb-4 opacity-50">
                                    {[1, 2, 3, 4, 5].map(n => (
                                        <div key={n} 
                                            className={`rune-card pointer-events-auto cursor-pointer ${detectedFingers === n ? 'highlight' : ''}`}
                                            onClick={() => triggerGift(n)} 
                                        >
                                            {n}
                                        </div>
                                    ))}
                                </div>
                                <p className="text-gray-400 text-sm bg-black/50 px-4 py-1 rounded-full border border-gray-700">
                                    {useCamera ? "‚úã Gi∆° ng√≥n tay (1-5) v√† gi·ªØ y√™n 1 gi√¢y" : "üñ±Ô∏è B·∫•m v√†o s·ªë ·ªü tr√™n ƒë·ªÉ ch·ªçn"}
                                </p>
                            </div>
                        )}

                        {/* SPINNING */}
                        {isSpinning && (
                            <div className="text-center animate__animated animate__pulse animate__infinite z-50">
                                <div className="text-8xl mb-4 opacity-80" style={{filter: 'drop-shadow(0 0 20px cyan)'}}>‚òØÔ∏è</div>
                                <div className="text-3xl title-font text-yellow-300">ƒêang V·∫≠n Chuy·ªÉn...</div>
                            </div>
                        )}

                        {/* WINNERS */}
                        {winners.length > 0 && (
                            <div className="flex flex-col items-center animate__animated animate__zoomIn z-50 w-full max-w-5xl">
                                <h2 className="text-5xl title-font text-yellow-400 mb-10 drop-shadow-[0_0_15px_red]">ƒê·∫°i C∆° Duy√™n</h2>
                                <div className="flex flex-wrap justify-center gap-8 mb-10">
                                    {winners.map((w, i) => (
                                        <div key={i} className="winner-card px-8 py-6 rounded-lg text-center min-w-[240px]">
                                            <div className="text-5xl mb-4">üéÅ</div>
                                            <div className="text-3xl font-bold text-cyan-300 font-serif" style={{fontFamily: 'Merriweather'}}>{w}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="flex gap-6 pointer-events-auto">
                                    <button onClick={() => setWinners([])} className="px-8 py-3 bg-gray-800 border border-gray-500 text-gray-300 rounded hover:bg-gray-700 font-bold uppercase">Gi·ªØ L·∫°i</button>
                                    <button onClick={() => {
                                        setStudentList(prev => prev.filter(s => !winners.includes(s)));
                                        setWinners([]);
                                    }} className="px-8 py-3 bg-red-900 border border-red-500 text-white rounded hover:bg-red-700 shadow-[0_0_20px_red] font-bold uppercase">X√≥a T√™n & Ti·∫øp T·ª•c</button>
                                </div>
                            </div>
                        )}

                        {/* START SCREEN */}
                        {appState === "INIT" && (
                            <div className="glass-panel p-10 text-center max-w-lg pointer-events-auto border-2 border-yellow-600">
                                <h1 className="text-5xl title-font text-yellow-500 mb-2">Thi√™n C∆° B·∫£ng</h1>
                                <p className="text-gray-400 mb-8 italic">"V·∫°n s·ª± t√πy duy√™n, v·∫≠n kh√≠ do tr·ªùi"</p>
                                <div className="space-y-4">
                                    <button onClick={() => startSystem(true)} className="w-full py-4 bg-gradient-to-r from-cyan-900 to-blue-900 text-white border border-cyan-500 rounded hover:scale-105 transition-transform font-bold text-lg shadow-[0_0_15px_cyan]">
                                        <i className="fas fa-hand-sparkles mr-3"></i> K·∫øt ·∫§n (Camera)
                                    </button>
                                    <button onClick={() => startSystem(false)} className="w-full py-3 bg-transparent text-gray-400 border border-gray-700 rounded hover:bg-gray-800 font-bold">
                                        <i className="fas fa-mouse mr-3"></i> D√πng Chu·ªôt
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* LOADING */}
                        {appState === "LOADING" && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center bg-black z-[200]">
                                <div className="text-6xl animate-spin mb-6 text-cyan-500">üí†</div>
                                <div className="text-2xl text-yellow-500 font-serif">ƒêang khai m·ªü linh tr·∫≠n...</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>