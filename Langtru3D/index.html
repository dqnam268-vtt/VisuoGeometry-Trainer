<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng G·∫•p LƒÉng Tr·ª• & Cavalieri</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        #canvas-container {
            width: 90vw;
            height: 50vh;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            position: relative;
        }
        #controls-container {
            width: 90vw;
            max-width: 900px;
            margin-top: 10px;
            padding: 10px 15px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 45vh;
            overflow-y: auto;
        }
        
        /* --- Styles Modal C√¥ng th·ª©c --- */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.5); 
            backdrop-filter: blur(2px);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 2% auto; 
            padding: 20px;
            border: 1px solid #888;
            width: 95%;
            max-width: 750px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.25);
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: sticky;
            top: 0;
            right: 0;
        }
        .close-btn:hover { color: #e74c3c; }
        
        .formula-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .formula-card {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            background: #fff;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .formula-card svg {
            width: 90px;
            height: 90px;
            flex-shrink: 0;
            stroke: #34495e;
            stroke-width: 2;
            fill: none;
        }
        .formula-info { flex-grow: 1; }
        .formula-card h5 { margin: 0 0 5px 0; color: #2980b9; font-size: 1em; }
        .formula-card p { margin: 3px 0; font-size: 0.95em; line-height: 1.5; color: #444; }
        
        .svg-label { font-size: 11px; fill: #e74c3c; stroke: none; font-weight: bold; font-family: sans-serif; }
        .svg-line-dim { stroke: #95a5a6; stroke-width: 1; stroke-dasharray: 2,2; }
        
        /* --- Styles T√≠nh to√°n --- */
        #calculation-box {
            background-color: #f9fbe7;
            border: 1px solid #dce775;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.9em;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .calc-section h4 {
            margin: 0 0 5px 0;
            color: #2e7d32;
            border-bottom: 1px dashed #a5d6a7;
            padding-bottom: 3px;
        }
        .calc-line { margin-bottom: 4px; line-height: 1.4; }
        .formula { font-weight: bold; color: #555; }
        .step { color: #1976d2; font-style: italic; }
        .result { font-weight: bold; color: #d32f2f; }
        .highlight-cavalieri { background-color: #e3f2fd; padding: 2px 5px; border-radius: 3px; color: #0277bd; font-weight: bold; }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
            background: #eee;
            padding: 5px 10px;
            border-radius: 20px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            flex-wrap: wrap;
        }
        /* Tab style switch */
        .view-switch {
            display: flex;
            background: #e0e0e0;
            border-radius: 20px;
            padding: 3px;
            margin-bottom: 8px;
            justify-content: center;
            width: fit-content;
            margin-left: auto; margin-right: auto;
        }
        .view-btn {
            padding: 6px 15px;
            border-radius: 17px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9em;
            background: transparent;
            color: #555;
            transition: all 0.2s;
        }
        .view-btn.active {
            background: white;
            color: #2980b9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .preset-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }
        .preset-btn, .formula-btn, .play-btn, .cavalieri-btn {
            padding: 4px 8px;
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }
        .formula-btn { background-color: #8e44ad; color: white; border: none; }
        .formula-btn:hover { background-color: #9b59b6; }
        
        .play-btn, .cavalieri-btn {
            background-color: #e67e22; 
            color: white; 
            border: none; 
            min-width: 80px;
            font-weight: bold;
        }
        .play-btn:hover, .cavalieri-btn:hover { background-color: #d35400; }
        .play-btn.playing, .cavalieri-btn.running { background-color: #c0392b; }

        .preset-btn:hover { background-color: #dfe6e9; }
        .preset-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #2980b9;
        }
        .input-group {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px;
            border: 1px solid #eee;
            border-radius: 8px;
        }
        .input-item {
            display: flex;
            flex-direction: column;
            font-size: 0.85em;
        }
        input[type="number"] {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 60px;
        }
        input.auto-calc {
            background-color: #f3f3f3;
            color: #7f8c8d;
            cursor: not-allowed;
        }
        input[type="range"] { width: 100%; cursor: pointer; }
        button.update-btn {
            padding: 6px 12px;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        button.update-btn:hover { background-color: #2ecc71; }
        #error-msg {
            color: #e74c3c;
            font-size: 0.9em;
            margin-top: 5px;
            text-align: center;
            display: none;
            font-weight: bold;
        }
        #instructions {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.85em;
            pointer-events: none;
        }
        .hidden { display: none !important; }
        @media (max-width: 600px) {
            #calculation-box, .formula-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="instructions">
            K√©o chu·ªôt ƒë·ªÉ xoay | LƒÉn chu·ªôt ƒë·ªÉ thu/ph√≥ng
        </div>
    </div>
    
    <div id="controls-container">
        <!-- Main Mode Switcher -->
        <div class="view-switch">
            <button class="view-btn active" id="btn-view-fold" onclick="switchViewMode('fold')">Chi·∫øc √Åo LƒÉng Tr·ª•</button>
            <button class="view-btn" id="btn-view-cavalieri" onclick="switchViewMode('cavalieri')">Chi·∫øc H·ªôp Cavalieri</button>
        </div>

        <div style="display:flex; justify-content:center; gap:10px; align-items:center; margin-bottom:5px;">
            <div class="mode-selector" style="margin:0;">
                <label style="cursor: pointer;"><input type="radio" name="prismMode" value="triangle" checked onchange="toggleMode()"> LƒÉng tr·ª• Tam gi√°c</label>
                <label style="cursor: pointer;"><input type="radio" name="prismMode" value="quad" onchange="toggleMode()"> LƒÉng tr·ª• T·ª© gi√°c</label>
            </div>
            <button class="formula-btn" onclick="toggleFormulaModal()">üìñ Tra c·ª©u C√¥ng th·ª©c</button>
        </div>

        <!-- Presets -->
        <div id="tri-presets" class="preset-buttons">
            <button class="preset-btn active" onclick="setTriPreset('general')">Th∆∞·ªùng</button>
            <button class="preset-btn" onclick="setTriPreset('isosceles')">C√¢n</button>
            <button class="preset-btn" onclick="setTriPreset('equilateral')">ƒê·ªÅu</button>
            <button class="preset-btn" onclick="setTriPreset('right')">Vu√¥ng (3-4-5)</button>
        </div>
        <div id="quad-presets" class="preset-buttons hidden">
            <button class="preset-btn" onclick="setQuadPreset('square')">H√¨nh vu√¥ng</button>
            <button class="preset-btn" onclick="setQuadPreset('rhombus')">H√¨nh thoi</button>
            <button class="preset-btn" onclick="setQuadPreset('rect')">H√¨nh ch·ªØ nh·∫≠t</button>
            <button class="preset-btn" onclick="setQuadPreset('parallelogram')">H√¨nh b√¨nh h√†nh</button>
            <button class="preset-btn" onclick="setQuadPreset('trapezoid')">H√¨nh thang</button>
            <button class="preset-btn active" onclick="setQuadPreset('general')">T·ª© gi√°c th∆∞·ªùng</button>
        </div>

        <!-- Input Area (Shared) -->
        <div class="input-group">
            <div class="input-item">
                <label>Chi·ªÅu cao (H)</label>
                <input type="number" id="inp-height" value="3.5" min="0.5" step="0.1" oninput="updateDimensions()">
            </div>

            <!-- Inputs Tam Gi√°c -->
            <div class="input-item tri-only">
                <label>Tr√°i (c)</label>
                <input type="number" id="inp-tri-left" value="3" min="0.1" step="0.1" oninput="syncInputs('tri', 'left')">
            </div>
            <div class="input-item tri-only" style="background: #e8f5e9; border-radius: 4px; padding: 0 4px;">
                <label style="color: #2e7d32; font-weight:bold;">ƒê√°y (a)</label>
                <input type="number" id="inp-tri-center" value="4" min="0.1" step="0.1" oninput="syncInputs('tri', 'center')">
            </div>
            <div class="input-item tri-only">
                <label>Ph·∫£i (b)</label>
                <input type="number" id="inp-tri-right" value="2.5" min="0.1" step="0.1" oninput="syncInputs('tri', 'right')">
            </div>
            
            <div class="input-item tri-only" style="border-left: 2px solid #ddd; padding-left: 8px;">
                <label title="Thay ƒë·ªïi chi·ªÅu cao s·∫Ω t·∫°o tam gi√°c c√¢n">Cao ƒë√°y (h)</label>
                <input type="number" id="inp-tri-height" value="2" min="0.1" step="0.1" onchange="updateTriFromHeight()">
            </div>

            <!-- Inputs T·ª© Gi√°c -->
            <div class="input-item quad-only hidden">
                <label>C·∫°nh 1 (Tr√°i)</label>
                <input type="number" id="inp-quad-1" value="3" min="0.1" step="0.1" oninput="syncInputs('quad', 1)">
            </div>
            <div class="input-item quad-only hidden">
                <label style="color:#2980b9; font-weight:bold;">C·∫°nh 2 (ƒê√°y)</label>
                <input type="number" id="inp-quad-2" value="4" min="0.1" step="0.1" oninput="syncInputs('quad', 2)">
            </div>
            <div class="input-item quad-only hidden">
                <label>C·∫°nh 3 (Ph·∫£i)</label>
                <input type="number" id="inp-quad-3" value="3" min="0.1" step="0.1" oninput="syncInputs('quad', 3)">
            </div>
            <div class="input-item quad-only hidden">
                <label style="color:#2980b9; font-weight:bold;">C·∫°nh 4 (ƒê√°y)</label>
                <input type="number" id="inp-quad-4" value="2" min="0.1" step="0.1" oninput="syncInputs('quad', 4)">
            </div>
            <div class="input-item quad-only hidden">
                <label>G√≥c C2-C3</label>
                <input type="number" id="inp-quad-angle" value="75" min="10" max="170" step="1" oninput="updateDimensions()">
            </div>

            <button class="update-btn" onclick="updateDimensions()">C·∫≠p nh·∫≠t H√¨nh</button>
        </div>
        
        <div id="error-msg">Th√¥ng s·ªë kh√¥ng h·ª£p l·ªá!</div>

        <!-- Calculation Box -->
        <div id="calculation-box">
            <div class="calc-section">
                <h4>Chu vi & Di·ªán t√≠ch ƒê√°y</h4>
                <div id="calc-base" class="calc-line"></div>
                <div id="calc-area-base" class="calc-line"></div>
            </div>
            <div class="calc-section">
                <h4>Di·ªán t√≠ch & Th·ªÉ t√≠ch</h4>
                <div id="calc-lateral" class="calc-line"></div>
                <div id="calc-total" class="calc-line"></div>
                <div id="calc-volume" class="calc-line"></div>
            </div>
        </div>

        <hr style="width: 100%; border: 0; border-top: 1px solid #eee;">

        <!-- Fold Slider (Only for Fold Mode) -->
        <div id="fold-controls" class="input-item" style="width: 100%; display: flex; align-items: center; gap: 15px;">
            <button id="btn-play" class="play-btn" onclick="togglePlay()">‚ñ∂ G·∫•p T·ª± ƒë·ªông</button>
            <div style="flex-grow: 1;">
                <label for="fold-slider" style="text-align: center; display: block;">M·ªü <span id="slider-value">0</span>% G·∫•p</label>
                <input type="range" id="fold-slider" min="0" max="100" value="0" step="0.1">
            </div>
        </div>

        <!-- Cavalieri Controls (Only for Cavalieri Mode) -->
        <div id="cavalieri-controls" class="input-item hidden" style="width: 100%; display: flex; align-items: center; gap: 15px; background: #e3f2fd; padding: 10px; border-radius: 8px;">
            <div class="input-item">
                <label style="font-weight:bold; color:#0277bd;">B∆∞·ªõc nh·∫£y (Œîh)</label>
                <input type="number" id="inp-cavalieri-step" value="0.5" min="0.1" step="0.1" style="width: 80px;">
            </div>
            <button id="btn-cavalieri-run" class="cavalieri-btn" onclick="toggleCavalieriRun()">‚ñ∂ B·∫Øt ƒë·∫ßu x·∫øp ch·ªìng</button>
            <button class="preset-btn" onclick="resetCavalieri()" style="background:#fff;">‚ü≤ ƒê·∫∑t l·∫°i</button>
            <div style="flex-grow: 1; text-align: right; font-size: 0.9em; line-height: 1.4;">
                <div id="cavalieri-status">ƒêang ch·ªù...</div>
            </div>
        </div>
    </div>

    <!-- Modal C√¥ng Th·ª©c (Gi·ªØ nguy√™n) -->
    <div id="formula-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="toggleFormulaModal()">&times;</span>
            <h2 style="text-align:center; color:#2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px;">S·ªï Tay C√¥ng Th·ª©c H√¨nh H·ªçc</h2>
            
            <div class="formula-grid">
                <!-- Tam gi√°c th∆∞·ªùng -->
                <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <polygon points="10,80 50,20 90,80" stroke="#333" fill="#e8f6f3"/>
                        <line x1="50" y1="20" x2="50" y2="80" class="svg-line-dim" />
                        <text x="52" y="55" class="svg-label">h</text>
                        <text x="50" y="95" class="svg-label" text-anchor="middle">a</text>
                    </svg>
                    <div class="formula-info">
                        <h5>Tam gi√°c th∆∞·ªùng</h5>
                        <p>Chu vi: P = a + b + c</p>
                        <p>Di·ªán t√≠ch: S = ¬Ω √ó a √ó h</p>
                    </div>
                </div>

                <!-- Tam gi√°c vu√¥ng -->
                <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <polygon points="20,80 20,20 80,80" stroke="#333" fill="#fff5e6"/>
                        <rect x="20" y="70" width="10" height="10" stroke="#333" fill="none"/>
                        <text x="10" y="50" class="svg-label">a</text>
                        <text x="50" y="95" class="svg-label" text-anchor="middle">b</text>
                    </svg>
                    <div class="formula-info">
                        <h5>Tam gi√°c vu√¥ng</h5>
                        <p>Di·ªán t√≠ch: S = ¬Ω √ó a √ó b</p>
                        <p style="font-size:0.8em; color:#7f8c8d;">(a, b l√† 2 c·∫°nh g√≥c vu√¥ng)</p>
                    </div>
                </div>

                <!-- H√¨nh vu√¥ng -->
                <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <rect x="20" y="20" width="60" height="60" stroke="#333" fill="#eaf2f8"/>
                        <text x="50" y="95" class="svg-label" text-anchor="middle">a</text>
                        <text x="10" y="55" class="svg-label">a</text>
                    </svg>
                    <div class="formula-info">
                        <h5>H√¨nh vu√¥ng</h5>
                        <p>Chu vi: P = 4 √ó a</p>
                        <p>Di·ªán t√≠ch: S = a¬≤</p>
                    </div>
                </div>

                <!-- H√¨nh ch·ªØ nh·∫≠t -->
                <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <rect x="10" y="30" width="80" height="40" stroke="#333" fill="#fdedec"/>
                        <text x="50" y="85" class="svg-label" text-anchor="middle">a</text>
                        <text x="2" y="55" class="svg-label">b</text>
                    </svg>
                    <div class="formula-info">
                        <h5>H√¨nh ch·ªØ nh·∫≠t</h5>
                        <p>Chu vi: P = (a + b) √ó 2</p>
                        <p>Di·ªán t√≠ch: S = a √ó b</p>
                    </div>
                </div>

                <!-- H√¨nh b√¨nh h√†nh -->
                <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <polygon points="25,80 75,80 95,30 45,30" stroke="#333" fill="#f4ecf7"/>
                        <line x1="45" y1="30" x2="45" y2="80" class="svg-line-dim" />
                        <text x="50" y="95" class="svg-label" text-anchor="middle">a</text>
                        <text x="38" y="60" class="svg-label">h</text>
                    </svg>
                    <div class="formula-info">
                        <h5>H√¨nh b√¨nh h√†nh</h5>
                        <p>Di·ªán t√≠ch: S = a √ó h</p>
                    </div>
                </div>

                <!-- H√¨nh thoi -->
                <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <polygon points="50,10 80,50 50,90 20,50" stroke="#333" fill="#e8f8f5"/>
                        <line x1="50" y1="10" x2="50" y2="90" class="svg-line-dim" />
                        <line x1="20" y1="50" x2="80" y2="50" class="svg-line-dim" />
                        <text x="52" y="30" class="svg-label">d1</text>
                        <text x="65" y="48" class="svg-label">d2</text>
                    </svg>
                    <div class="formula-info">
                        <h5>H√¨nh thoi</h5>
                        <p>Di·ªán t√≠ch: S = ¬Ω √ó d1 √ó d2</p>
                    </div>
                </div>

                 <!-- H√¨nh thang -->
                 <div class="formula-card">
                    <svg viewBox="0 0 100 100">
                        <polygon points="15,80 85,80 65,30 35,30" stroke="#333" fill="#fef9e7"/>
                        <line x1="35" y1="30" x2="35" y2="80" class="svg-line-dim" />
                        <!-- S·ª≠ d·ª•ng text-anchor="middle" ƒë·ªÉ cƒÉn gi·ªØa text -->
                        <text x="50" y="95" class="svg-label" text-anchor="middle">a (ƒë√°y l·ªõn)</text>
                        <text x="50" y="25" class="svg-label" text-anchor="middle">b (ƒë√°y nh·ªè)</text>
                        <text x="25" y="60" class="svg-label" text-anchor="middle">h</text>
                    </svg>
                    <div class="formula-info">
                        <h5>H√¨nh thang</h5>
                        <p>Di·ªán t√≠ch: S = ¬Ω √ó (a + b) √ó h</p>
                        <p style="font-size:0.8em; color:#666;">(L∆∞u √Ω: 2 c·∫°nh ƒë√°y lu√¥n song song)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let centralFace, hingeLeft, hingeRight, hingeFarRight; 
        let leftFace, rightFace, farRightFace;
        let baseTop, baseBottom, hingeTop, hingeBottom;
        let prismGroup; // Group ch·ª©a to√†n b·ªô m√¥ h√¨nh g·∫•p
        let cavalieriGroup; // Group ch·ª©a m√¥ h√¨nh x·∫øp ch·ªìng

        let currentMode = 'triangle'; 
        let currentView = 'fold'; // 'fold' ho·∫∑c 'cavalieri'
        let currentPreset = 'general';
        let height = 3.5;
        let triData = { a: 4, b: 3, c: 2, angleLeft: 0, angleRight: 0 };
        let quadData = { s1: 3, s2: 4, s3: 3, s4: 2, angle23: 75, vertices: [], angles: [] };
        
        // D·ªØ li·ªáu di·ªán t√≠ch ƒë√°y (t√≠nh to√°n cache)
        let cachedBaseArea = 0;

        // Animation vars for Fold
        let isPlaying = false;
        let playDirection = 1;
        let animationValue = 0;

        // Vars for Cavalieri
        let isCavalieriRunning = false;
        let cavalieriHeight = 0;
        let cavalieriTimer = null;

        const slider = document.getElementById('fold-slider');
        const sliderValueLabel = document.getElementById('slider-value');
        const container = document.getElementById('canvas-container');
        const errorMsg = document.getElementById('error-msg');
        const quadPresets = document.getElementById('quad-presets');
        const triPresets = document.getElementById('tri-presets');
        const btnPlay = document.getElementById('btn-play');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, 16);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            const gridHelper = new THREE.GridHelper(40, 40, 0xcccccc, 0xcccccc);
            gridHelper.position.y = 0; // ƒê·∫∑t grid ·ªü 0 cho Cavalieri d·ªÖ nh√¨n
            gridHelper.name = 'gridHelper';
            scene.add(gridHelper);

            // Init Groups
            prismGroup = new THREE.Group();
            scene.add(prismGroup);
            
            cavalieriGroup = new THREE.Group();
            cavalieriGroup.visible = false;
            scene.add(cavalieriGroup);

            calculateTriangle();
            createPrism(); // T·∫°o m√¥ h√¨nh g·∫•p
            updateCalculations();

            // Ch·ªânh l·∫°i v·ªã tr√≠ Grid v√† PrismGroup ƒë·ªÉ kh·ªõp visual
            // M·∫∑c ƒë·ªãnh PrismGroup ƒë∆∞·ª£c t·∫°o xung quanh t√¢m 0, ta n√¢ng n√≥ l√™n ho·∫∑c h·∫° grid
            // ƒê·ªÉ th·ªëng nh·∫•t: Grid t·∫°i y=0.
            // Prism g·∫•p s·∫Ω ƒëi·ªÅu ch·ªânh v·ªã tr√≠ trong updateDimensions
            
            window.addEventListener('resize', onWindowResize);
            slider.addEventListener('input', onSliderUserInteraction);
        }

        // --- VIEW SWITCHING ---
        function switchViewMode(mode) {
            currentView = mode;
            document.getElementById('btn-view-fold').classList.toggle('active', mode === 'fold');
            document.getElementById('btn-view-cavalieri').classList.toggle('active', mode === 'cavalieri');

            if (mode === 'fold') {
                prismGroup.visible = true;
                cavalieriGroup.visible = false;
                document.getElementById('fold-controls').classList.remove('hidden');
                document.getElementById('cavalieri-controls').classList.add('hidden');
                resetCavalieri(); // D·ª´ng cavalieri n·∫øu ƒëang ch·∫°y
                
                // C·∫≠p nh·∫≠t v·ªã tr√≠ grid cho ch·∫ø ƒë·ªô g·∫•p (gi·ªØa lƒÉng tr·ª•)
                const grid = scene.getObjectByName('gridHelper');
                if(grid) grid.position.y = -height/2; 
                
            } else {
                prismGroup.visible = false;
                cavalieriGroup.visible = true;
                document.getElementById('fold-controls').classList.add('hidden');
                document.getElementById('cavalieri-controls').classList.remove('hidden');
                
                // C·∫≠p nh·∫≠t v·ªã tr√≠ grid cho ch·∫ø ƒë·ªô cavalieri (ch√¢n lƒÉng tr·ª•)
                const grid = scene.getObjectByName('gridHelper');
                if(grid) grid.position.y = 0;

                // Reset v√† chu·∫©n b·ªã stack m·ªõi
                resetCavalieri();
            }
        }
        window.switchViewMode = switchViewMode;

        // --- PLAY CONTROL (FOLD) ---
        function togglePlay() {
            isPlaying = !isPlaying;
            if (isPlaying) {
                btnPlay.textContent = "‚è∏ D·ª´ng";
                btnPlay.classList.add('playing');
                animationValue = parseFloat(slider.value);
            } else {
                btnPlay.textContent = "‚ñ∂ G·∫•p T·ª± ƒë·ªông";
                btnPlay.classList.remove('playing');
            }
        }
        window.togglePlay = togglePlay;

        function onSliderUserInteraction(event) {
            if (isPlaying) togglePlay();
            onSliderChange(event);
        }

        // --- CAVALIERI LOGIC ---
        function toggleCavalieriRun() {
            const btn = document.getElementById('btn-cavalieri-run');
            if (isCavalieriRunning) {
                stopCavalieri();
            } else {
                // N·∫øu ƒë√£ full height, reset ƒë·ªÉ ch·∫°y l·∫°i
                if (cavalieriHeight >= height - 0.01) {
                    resetCavalieri();
                }
                
                isCavalieriRunning = true;
                btn.textContent = "‚è∏ T·∫°m d·ª´ng";
                btn.classList.add('running');
                
                // L·∫•y step
                const step = parseFloat(document.getElementById('inp-cavalieri-step').value) || 0.5;
                
                // B·∫Øt ƒë·∫ßu interval
                cavalieriTimer = setInterval(() => {
                    addCavalieriSlice(step);
                }, 500); // T·ªëc ƒë·ªô th√™m l·ªõp (500ms)
            }
        }
        window.toggleCavalieriRun = toggleCavalieriRun;

        function stopCavalieri() {
            isCavalieriRunning = false;
            clearInterval(cavalieriTimer);
            const btn = document.getElementById('btn-cavalieri-run');
            btn.textContent = "‚ñ∂ B·∫Øt ƒë·∫ßu x·∫øp ch·ªìng";
            btn.classList.remove('running');
        }

        function resetCavalieri() {
            stopCavalieri();
            // X√≥a h·∫øt children trong cavalieriGroup
            while(cavalieriGroup.children.length > 0){ 
                const obj = cavalieriGroup.children[0];
                cavalieriGroup.remove(obj);
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) {
                    if(Array.isArray(obj.material)) obj.material.forEach(m=>m.dispose());
                    else obj.material.dispose();
                }
            }
            cavalieriHeight = 0;
            updateCavalieriStatus();
        }
        window.resetCavalieri = resetCavalieri;

        function addCavalieriSlice(step) {
            const targetH = height;
            
            // T√≠nh to√°n chi·ªÅu cao th·ª±c t·∫ø c·ªßa slice n√†y (x·ª≠ l√Ω ph·∫ßn d∆∞ cu·ªëi c√πng)
            let actualStep = step;
            if (cavalieriHeight + step > targetH) {
                actualStep = targetH - cavalieriHeight;
            }

            if (actualStep <= 0.001) {
                stopCavalieri();
                return;
            }

            // T·∫°o Mesh cho slice
            const shape = getBaseShape();
            const extrudeSettings = {
                steps: 1,
                depth: actualStep,
                bevelEnabled: false
            };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Xoay geometry ƒë·ªÉ n√≥ n·∫±m ngang (Extrude m·∫∑c ƒë·ªãnh d·ªçc Z)
            geometry.rotateX(-Math.PI / 2);

            // --- COLOR LOGIC: T·∫°o m√†u ng·∫´u nhi√™n nh∆∞ng h√†i h√≤a ---
            // D√πng HSL ƒë·ªÉ ki·ªÉm so√°t ƒë·ªô t∆∞∆°i v√† s√°ng, ch·ªâ thay ƒë·ªïi Hue (s·∫Øc th√°i)
            // Shift Hue d·ª±a tr√™n s·ªë l∆∞·ª£ng slice ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng c·∫ßu v·ªìng
            const hue = (cavalieriGroup.children.length * 0.137) % 1; // 0.137 l√† s·ªë nguy√™n t·ªë ƒë·ªÉ tr√°nh l·∫∑p l·∫°i m√†u qu√° g·∫ßn
            const randomColor = new THREE.Color().setHSL(hue, 0.85, 0.6);

            // V·∫≠t li·ªáu: M√†u h∆°i trong su·ªët ƒë·ªÉ th·∫•y s·ª± x·∫øp ch·ªìng
            const material = new THREE.MeshStandardMaterial({ 
                color: randomColor, 
                transparent: true, 
                opacity: 0.85,
                metalness: 0.1, 
                roughness: 0.5 
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // T·∫°o vi·ªÅn ƒëen cho l√°t c·∫Øt
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2, transparent: true, opacity: 0.5 }));
            mesh.add(line);

            // ƒê·ªãnh v·ªã: Y b·∫Øt ƒë·∫ßu t·ª´ cavalieriHeight hi·ªán t·∫°i
            mesh.position.y = cavalieriHeight;
            
            cavalieriGroup.add(mesh);
            cavalieriHeight += actualStep;

            updateCavalieriStatus();

            if (Math.abs(cavalieriHeight - targetH) < 0.001) {
                stopCavalieri();
            }
        }

        function getBaseShape() {
            const shape = new THREE.Shape();
            
            if (currentMode === 'triangle') {
                const a = triData.a; const b = triData.b; const c = triData.c;
                // Vertices t·ª´ logic t·∫°o n·∫Øp lƒÉng tr·ª•
                const theta = triData.angleLeft;
                const ax_rel = -triData.c * Math.cos(theta); 
                const az_rel = triData.c * Math.sin(theta);
                const Ax = -triData.a/2 + ax_rel; 
                const Az = az_rel;
                
                // Map to Shape (x, y) -> (x, z c·ªßa 3D)
                // ƒê·ªânh 1: (Ax, Az)
                // ƒê·ªânh 2: (-a/2, 0)
                // ƒê·ªânh 3: (a/2, 0)
                shape.moveTo(Ax, Az);
                shape.lineTo(triData.a/2, 0);
                shape.lineTo(-triData.a/2, 0);
                shape.lineTo(Ax, Az);
            } else {
                const v = quadData.vertices;
                if (v && v.length === 4) {
                    shape.moveTo(v[0].x, v[0].z);
                    shape.lineTo(v[1].x, v[1].z);
                    shape.lineTo(v[2].x, v[2].z);
                    shape.lineTo(v[3].x, v[3].z);
                    shape.lineTo(v[0].x, v[0].z);
                }
            }
            return shape;
        }

        function updateCavalieriStatus() {
            const S = cachedBaseArea;
            const H_curr = cavalieriHeight;
            const V_curr = S * H_curr;
            
            const statusDiv = document.getElementById('cavalieri-status');
            statusDiv.innerHTML = `
                S<sub>ƒë√°y</sub>: <b>${S.toFixed(2)}</b> &nbsp;|&nbsp; 
                H<sub>hi·ªán t·∫°i</sub>: <b style="color:#d35400">${H_curr.toFixed(2)}</b><br>
                V<sub>t√≠ch l≈©y</sub> = ${S.toFixed(2)} √ó ${H_curr.toFixed(2)} = <b style="color:#27ae60; font-size:1.1em;">${V_curr.toFixed(2)}</b>
            `;
        }

        // --- COMMON LOGIC ---
        function toggleFormulaModal() {
            const modal = document.getElementById('formula-modal');
            if (modal.style.display === "block") {
                modal.style.display = "none";
            } else {
                modal.style.display = "block";
            }
        }
        window.toggleFormulaModal = toggleFormulaModal;

        window.onclick = function(event) {
            const modal = document.getElementById('formula-modal');
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        function updateTriFromHeight() {
            const h = parseFloat(document.getElementById('inp-tri-height').value);
            const a = parseFloat(document.getElementById('inp-tri-center').value);
            if (h > 0 && a > 0) {
                const leg = Math.sqrt(h*h + (a/2)*(a/2));
                document.getElementById('inp-tri-left').value = leg.toFixed(2);
                document.getElementById('inp-tri-right').value = leg.toFixed(2);
                currentPreset = 'isosceles';
                const btns = document.querySelectorAll('#tri-presets .preset-btn');
                btns.forEach(b => b.classList.remove('active'));
                updateDimensions();
            }
        }
        window.updateTriFromHeight = updateTriFromHeight;

        function updateCalculations() {
            const H_prism = height;
            let perimeterBase = 0;
            let areaBase = 0;
            let perimeterText = "";
            let areaBaseText = "";
            let volumeStep = "";

            if (currentMode === 'triangle') {
                const s1 = triData.c; 
                const s2 = triData.a; 
                const s3 = triData.b; 

                perimeterBase = s1 + s2 + s3;
                perimeterText = `<span class="formula">C = a + b + c</span><br><span class="step">${s1.toFixed(2)} + ${s2.toFixed(2)} + ${s3.toFixed(2)}</span> = <span class="result">${perimeterBase.toFixed(2)}</span>`;

                const p = perimeterBase / 2;
                areaBase = Math.sqrt(p * (p - s1) * (p - s2) * (p - s3));
                const h_a = (2 * areaBase) / s2;
                
                const h_display = parseFloat(h_a.toFixed(2));
                const area_visual = 0.5 * s2 * h_display;
                if (Math.abs(area_visual - areaBase) < 0.05) {
                    areaBase = area_visual;
                }

                const hInput = document.getElementById('inp-tri-height');
                if (document.activeElement !== hInput) hInput.value = h_a.toFixed(2);

                areaBaseText = `<span class="formula">S<sub>ƒë√°y</sub> = ¬Ω ¬∑ a ¬∑ h</span><br><span class="step">¬Ω ¬∑ ${s2} ¬∑ ${h_display.toFixed(2)}</span> = <span class="result">${areaBase.toFixed(2)}</span>`;
                volumeStep = `<span class="step">(¬Ω ¬∑ ${s2} ¬∑ ${h_display.toFixed(2)}) ¬∑ ${H_prism}</span>`;
            } else {
                const s1 = quadData.s1; const s2 = quadData.s2; const s3 = quadData.s3; const s4 = quadData.s4;
                perimeterBase = s1 + s2 + s3 + s4;
                perimeterText = `<span class="formula">C = s1 + s2 + s3 + s4</span><br><span class="step">${s1} + ${s2} + ${s3} + ${s4}</span> = <span class="result">${perimeterBase.toFixed(2)}</span>`;

                const v = quadData.vertices; 
                if (v.length === 4) {
                    const sum1 = v[0].x*v[1].z + v[1].x*v[2].z + v[2].x*v[3].z + v[3].x*v[0].z;
                    const sum2 = v[0].z*v[1].x + v[1].z*v[2].x + v[2].z*v[3].x + v[3].z*v[0].x;
                    areaBase = Math.abs(sum1 - sum2) / 2;
                }
                areaBaseText = `<span class="formula">S<sub>ƒë√°y</sub> (T·ªça ƒë·ªô)</span><br><span class="step">T√≠nh to√°n h√¨nh h·ªçc</span> = <span class="result">${areaBase.toFixed(2)}</span>`;
                volumeStep = `<span class="step">${areaBase.toFixed(2)} ¬∑ ${H_prism}</span>`;
            }

            cachedBaseArea = areaBase; // L∆∞u cache ƒë·ªÉ d√πng cho Cavalieri

            const lateralArea = perimeterBase * H_prism;
            const lateralText = `<span class="formula">S<sub>xq</sub> = C<sub>ƒë√°y</sub> ¬∑ H</span><br><span class="step">${perimeterBase.toFixed(2)} ¬∑ ${H_prism}</span> = <span class="result">${lateralArea.toFixed(2)}</span>`;

            const totalArea = lateralArea + 2 * areaBase;
            const totalText = `<span class="formula">S<sub>tp</sub> = S<sub>xq</sub> + 2¬∑S<sub>ƒë√°y</sub></span><br><span class="step">${lateralArea.toFixed(2)} + 2¬∑${areaBase.toFixed(2)}</span> = <span class="result">${totalArea.toFixed(2)}</span>`;

            const volume = areaBase * H_prism;
            const volumeText = `<span class="formula">V = S<sub>ƒë√°y</sub> ¬∑ H</span><br>${volumeStep} = <span class="result">${volume.toFixed(2)}</span>`;

            document.getElementById('calc-base').innerHTML = perimeterText;
            document.getElementById('calc-area-base').innerHTML = areaBaseText;
            document.getElementById('calc-lateral').innerHTML = lateralText;
            document.getElementById('calc-total').innerHTML = totalText;
            document.getElementById('calc-volume').innerHTML = volumeText;
            
            // C·∫≠p nh·∫≠t text Cavalieri n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô ƒë√≥
            updateCavalieriStatus();
        }
        window.updateCalculations = updateCalculations;

        function toggleMode() {
            const radios = document.getElementsByName('prismMode');
            for (let r of radios) if (r.checked) currentMode = r.value;

            const triInputs = document.querySelectorAll('.tri-only');
            const quadInputs = document.querySelectorAll('.quad-only');

            if (currentMode === 'triangle') {
                triInputs.forEach(el => el.classList.remove('hidden'));
                quadInputs.forEach(el => el.classList.add('hidden'));
                quadPresets.classList.add('hidden');
                triPresets.classList.remove('hidden');
                setTriPreset('general');
            } else {
                triInputs.forEach(el => el.classList.add('hidden'));
                quadInputs.forEach(el => el.classList.remove('hidden'));
                quadPresets.classList.remove('hidden');
                triPresets.classList.add('hidden');
                setQuadPreset('general'); 
            }
            updateDimensions();
        }
        window.toggleMode = toggleMode;

        function syncInputs(type, source) {
            if (type === 'quad') {
                const s1El = document.getElementById('inp-quad-1');
                const s2El = document.getElementById('inp-quad-2');
                const s3El = document.getElementById('inp-quad-3');
                const s4El = document.getElementById('inp-quad-4');
                const angEl = document.getElementById('inp-quad-angle');
                const val = parseFloat(document.getElementById(`inp-quad-${source}`).value);

                if (currentPreset === 'square' || currentPreset === 'rhombus') {
                    s1El.value = val; s2El.value = val; s3El.value = val; s4El.value = val;
                } else if (currentPreset === 'rect' || currentPreset === 'parallelogram') {
                    if (source === 1) s3El.value = val;
                    if (source === 3) s1El.value = val;
                    if (source === 2) s4El.value = val;
                    if (source === 4) s2El.value = val;
                } else if (currentPreset === 'trapezoid') {
                    const s1 = parseFloat(s1El.value); 
                    const s2 = parseFloat(s2El.value); 
                    const s3 = parseFloat(s3El.value); 
                    const s4 = parseFloat(s4El.value); 
                    
                    const diff = Math.abs(s2 - s4);
                    
                    if (diff > 0) {
                        const num = s3*s3 + diff*diff - s1*s1;
                        const den = 2 * s3 * diff;
                        if (den !== 0) {
                            const cosAng = num / den;
                            if (cosAng >= -1 && cosAng <= 1) {
                                let ang = Math.acos(cosAng) * 180 / Math.PI;
                                if (s4 > s2) ang = 180 - ang;
                                angEl.value = Math.round(ang);
                                angEl.classList.add('auto-calc');
                            }
                        }
                    } else if (diff === 0) {
                        angEl.classList.remove('auto-calc');
                    }
                }
            } else if (type === 'tri') {
                const lEl = document.getElementById('inp-tri-left');
                const cEl = document.getElementById('inp-tri-center');
                const rEl = document.getElementById('inp-tri-right');
                let val;
                if(source === 'left') val = parseFloat(lEl.value);
                if(source === 'center') val = parseFloat(cEl.value);
                if(source === 'right') val = parseFloat(rEl.value);

                if (currentPreset === 'equilateral') {
                    lEl.value = val; cEl.value = val; rEl.value = val;
                } else if (currentPreset === 'isosceles') {
                    if (source === 'left') rEl.value = val;
                    if (source === 'right') lEl.value = val;
                }
            }
            updateDimensions();
        }
        window.syncInputs = syncInputs;

        function setTriPreset(type) {
            currentPreset = type;
            const btns = document.querySelectorAll('#tri-presets .preset-btn');
            btns.forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            let l=3, c=4, r=2.5;
            switch(type) {
                case 'equilateral': l=3; c=3; r=3; break;
                case 'isosceles': l=3; c=2; r=3; break;
                case 'right': l=3; c=4; r=5; break;
                case 'general': l=3; c=4; r=2.5; break;
            }
            document.getElementById('inp-tri-left').value = l;
            document.getElementById('inp-tri-center').value = c;
            document.getElementById('inp-tri-right').value = r;
            updateDimensions();
        }
        window.setTriPreset = setTriPreset;

        function setQuadPreset(type) {
            currentPreset = type;
            const btns = document.querySelectorAll('#quad-presets .preset-btn');
            btns.forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');
            
            const angEl = document.getElementById('inp-quad-angle');
            angEl.classList.remove('auto-calc');
            angEl.disabled = false;

            let s1=3, s2=4, s3=3, s4=2, ang=90;
            switch(type) {
                case 'square': s1=3; s2=3; s3=3; s4=3; ang=90; break;
                case 'rhombus': s1=3; s2=3; s3=3; s4=3; ang=60; break;
                case 'rect': s1=2.5; s2=4; s3=2.5; s4=4; ang=90; break;
                case 'trapezoid': 
                    s1=2.5; s2=4; s3=3; s4=2; 
                    ang = Math.acos((3*3 + 2*2 - 2.5*2.5)/(2*3*2)) * 180 / Math.PI;
                    ang = Math.round(ang);
                    angEl.classList.add('auto-calc');
                    break;
                case 'parallelogram': s1=2.5; s2=4; s3=2.5; s4=4; ang=60; break;
                case 'general': s1=3; s2=4; s3=3.5; s4=2.5; ang=80; break;
            }
            document.getElementById('inp-quad-1').value = s1;
            document.getElementById('inp-quad-2').value = s2;
            document.getElementById('inp-quad-3').value = s3;
            document.getElementById('inp-quad-4').value = s4;
            document.getElementById('inp-quad-angle').value = ang;
            updateDimensions();
        }
        window.setQuadPreset = setQuadPreset;

        function updateDimensions() {
            height = parseFloat(document.getElementById('inp-height').value);
            
            // C·∫≠p nh·∫≠t v·ªã tr√≠ Grid t√πy theo ch·∫ø ƒë·ªô
            const grid = scene.getObjectByName('gridHelper');
            if (grid) {
                if (currentView === 'fold') {
                    grid.position.y = -height / 2;
                } else {
                    grid.position.y = 0;
                }
            }

            let valid = false;

            if (currentMode === 'triangle') {
                const l = parseFloat(document.getElementById('inp-tri-left').value);
                const c = parseFloat(document.getElementById('inp-tri-center').value);
                const r = parseFloat(document.getElementById('inp-tri-right').value);

                if (l + c > r && l + r > c && c + r > l) {
                    triData.c = l; triData.a = c; triData.b = r;
                    valid = true;
                    calculateTriangle();
                } else {
                    errorMsg.textContent = "Ba c·∫°nh kh√¥ng t·∫°o th√†nh tam gi√°c h·ª£p l·ªá!";
                }
            } else {
                const s1 = parseFloat(document.getElementById('inp-quad-1').value);
                const s2 = parseFloat(document.getElementById('inp-quad-2').value);
                const s3 = parseFloat(document.getElementById('inp-quad-3').value);
                const s4 = parseFloat(document.getElementById('inp-quad-4').value);
                const ang = parseFloat(document.getElementById('inp-quad-angle').value);

                const result = calculateQuadrilateralGeometry(s1, s2, s3, s4, ang);
                if (result) {
                    quadData.s1 = s1; quadData.s2 = s2; quadData.s3 = s3; quadData.s4 = s4;
                    quadData.angle23 = ang;
                    quadData.vertices = result.vertices;
                    quadData.angles = result.angles;
                    valid = true;
                } else {
                    errorMsg.textContent = "Kh√¥ng t·∫°o ƒë∆∞·ª£c t·ª© gi√°c l·ªìi v·ªõi th√¥ng s·ªë n√†y!";
                }
            }

            if (valid) {
                errorMsg.style.display = 'none';
                clearPrism();
                createPrism();
                updateCalculations(); 
                
                // N·∫øu ƒëang ·ªü Cavalieri, reset l·∫°i v√¨ ƒë√°y ƒë√£ ƒë·ªïi
                if (currentView === 'cavalieri') {
                    resetCavalieri();
                }
                
                if(!isPlaying && currentView === 'fold') {
                    applyRotation(parseFloat(slider.value) / 100);
                }
            } else {
                errorMsg.style.display = 'block';
            }
        }
        window.updateDimensions = updateDimensions;

        // --- MATH FUNCTIONS ---
        function calculateTriangle() {
            const a = triData.a; const b = triData.b; const c = triData.c;
            const cosB = (a*a + c*c - b*b) / (2 * a * c);
            const cosC = (a*a + b*b - c*c) / (2 * a * b);
            const clamp = (n) => Math.min(Math.max(n, -1), 1);
            triData.angleLeft = Math.PI - Math.acos(clamp(cosB));
            triData.angleRight = Math.PI - Math.acos(clamp(cosC));
        }

        function calculateQuadrilateralGeometry(s1, s2, s3, s4, angleDeg) {
            const rad = angleDeg * Math.PI / 180;
            const v2 = { x: -s2/2, z: 0 }; 
            const v3 = { x: s2/2, z: 0 };
            const v4 = { x: v3.x - s3 * Math.cos(rad), z: v3.z + s3 * Math.sin(rad) };
            const dx = v4.x - v2.x; const dz = v4.z - v2.z;
            const d = Math.sqrt(dx*dx + dz*dz);

            if (d > s1 + s4 || d < Math.abs(s1 - s4) || d === 0) return null;

            const a = (s1*s1 - s4*s4 + d*d) / (2*d);
            const h = Math.sqrt(Math.max(0, s1*s1 - a*a));
            const x2 = v2.x + a * (dx/d); const z2 = v2.z + a * (dz/d);
            const v1 = { x: x2 - h * (dz/d), z: z2 + h * (dx/d) };

            const vec21 = { x: v1.x - v2.x, z: v1.z - v2.z };
            const vec23 = { x: v3.x - v2.x, z: v3.z - v2.z };
            const angle2 = angleBetween(vec21, vec23);
            const vec43 = { x: v3.x - v4.x, z: v3.z - v4.z };
            const vec41 = { x: v1.x - v4.x, z: v1.z - v4.z };
            const angle4 = angleBetween(vec43, vec41);

            return { vertices: [v1, v2, v3, v4], angles: [0, angle2, rad, angle4] };
        }

        function angleBetween(vA, vB) {
            const dot = vA.x * vB.x + vA.z * vB.z;
            const magA = Math.sqrt(vA.x*vA.x + vA.z*vA.z);
            const magB = Math.sqrt(vB.x*vB.x + vB.z*vB.z);
            return Math.acos(Math.min(Math.max(dot / (magA * magB), -1), 1));
        }

        // --- 3D RENDER FUNCTIONS ---
        function clearPrism() {
            // X√≥a h·∫øt children trong prismGroup
            while(prismGroup.children.length > 0){ 
                const obj = prismGroup.children[0];
                prismGroup.remove(obj);
                // Dispose geometry/material
                obj.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                });
            }
            centralFace = null; hingeLeft = null; hingeRight = null; hingeFarRight = null;
            baseTop = null; baseBottom = null; hingeTop = null; hingeBottom = null;
        }

        function createPrism() {
            const materialFace = new THREE.MeshStandardMaterial({ color: 0xf39c12, side: THREE.DoubleSide, metalness: 0.1, roughness: 0.8 });
            const materialEdge = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
            const materialBase = new THREE.MeshStandardMaterial({ color: 0x3498db, side: THREE.DoubleSide, metalness: 0.1, roughness: 0.8 });

            if (currentMode === 'triangle') createTrianglePrism(materialFace, materialEdge, materialBase);
            else createQuadPrism(materialFace, materialEdge, materialBase);
        }

        function createTrianglePrism(matFace, matEdge, matBase) {
            const centralGeo = new THREE.PlaneGeometry(triData.a, height);
            centralFace = new THREE.Mesh(centralGeo, matFace);
            prismGroup.add(centralFace); addEdges(centralFace, matEdge);

            hingeLeft = new THREE.Group(); hingeLeft.position.x = -triData.a / 2; prismGroup.add(hingeLeft);
            const leftGeo = new THREE.PlaneGeometry(triData.c, height);
            leftFace = new THREE.Mesh(leftGeo, matFace); leftFace.position.x = -triData.c / 2; 
            hingeLeft.add(leftFace); addEdges(leftFace, matEdge);

            hingeRight = new THREE.Group(); hingeRight.position.x = triData.a / 2; prismGroup.add(hingeRight);
            const rightGeo = new THREE.PlaneGeometry(triData.b, height);
            rightFace = new THREE.Mesh(rightGeo, matFace); rightFace.position.x = triData.b / 2;
            hingeRight.add(rightFace); addEdges(rightFace, matEdge);

            const theta = triData.angleLeft;
            const ax_rel = -triData.c * Math.cos(theta); const az_rel = triData.c * Math.sin(theta);
            const Ax = -triData.a/2 + ax_rel; const Az = az_rel;
            const vertices = new Float32Array([Ax, 0, Az, -triData.a/2, 0, 0, triData.a/2, 0, 0]);
            const lidGeo = new THREE.BufferGeometry();
            lidGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            lidGeo.setIndex([0, 2, 1]); lidGeo.computeVertexNormals();

            baseTop = new THREE.Mesh(lidGeo, matBase); hingeTop = new THREE.Group(); hingeTop.position.y = height/2; prismGroup.add(hingeTop); hingeTop.add(baseTop);
            baseBottom = new THREE.Mesh(lidGeo.clone(), matBase); hingeBottom = new THREE.Group(); hingeBottom.position.y = -height/2; prismGroup.add(hingeBottom); hingeBottom.add(baseBottom);
        }

        function createQuadPrism(matFace, matEdge, matBase) {
            const w2 = quadData.s2;
            const centralGeo = new THREE.PlaneGeometry(w2, height);
            centralFace = new THREE.Mesh(centralGeo, matFace);
            prismGroup.add(centralFace); addEdges(centralFace, matEdge);

            const w1 = quadData.s1;
            hingeLeft = new THREE.Group(); hingeLeft.position.x = -w2 / 2; prismGroup.add(hingeLeft);
            const leftGeo = new THREE.PlaneGeometry(w1, height);
            leftFace = new THREE.Mesh(leftGeo, matFace); leftFace.position.x = -w1 / 2; 
            hingeLeft.add(leftFace); addEdges(leftFace, matEdge);

            const w3 = quadData.s3;
            hingeRight = new THREE.Group(); hingeRight.position.x = w2 / 2; prismGroup.add(hingeRight);
            const rightGeo = new THREE.PlaneGeometry(w3, height);
            rightFace = new THREE.Mesh(rightGeo, matFace); rightFace.position.x = w3 / 2; 
            hingeRight.add(rightFace); addEdges(rightFace, matEdge);

            const w4 = quadData.s4;
            hingeFarRight = new THREE.Group(); hingeFarRight.position.x = w3 / 2; rightFace.add(hingeFarRight); 
            const farRightGeo = new THREE.PlaneGeometry(w4, height);
            farRightFace = new THREE.Mesh(farRightGeo, matFace); farRightFace.position.x = w4 / 2;
            hingeFarRight.add(farRightFace); addEdges(farRightFace, matEdge);

            const v = quadData.vertices;
            const vertices = new Float32Array([
                v[0].x, 0, v[0].z, v[1].x, 0, v[1].z, v[2].x, 0, v[2].z,  
                v[0].x, 0, v[0].z, v[2].x, 0, v[2].z, v[3].x, 0, v[3].z   
            ]);
            const lidGeo = new THREE.BufferGeometry();
            lidGeo.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            lidGeo.computeVertexNormals();

            baseTop = new THREE.Mesh(lidGeo, matBase); hingeTop = new THREE.Group(); hingeTop.position.y = height/2; prismGroup.add(hingeTop); hingeTop.add(baseTop);
            baseBottom = new THREE.Mesh(lidGeo.clone(), matBase); hingeBottom = new THREE.Group(); hingeBottom.position.y = -height/2; prismGroup.add(hingeBottom); hingeBottom.add(baseBottom);
        }

        function addEdges(mesh, material) {
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const line = new THREE.LineSegments(edges, material);
            mesh.add(line);
        }

        function onSliderChange(event) {
            const t = event.target.value / 100; 
            sliderValueLabel.textContent = event.target.value;
            applyRotation(t);
        }
        
        function applyRotation(t) {
            if(!prismGroup.visible) return; 

             if (hingeTop) hingeTop.rotation.x = (t - 1) * (Math.PI / 2);
            if (hingeBottom) hingeBottom.rotation.x = (1 - t) * (Math.PI / 2);

            if (currentMode === 'triangle') {
                if (hingeLeft) hingeLeft.rotation.y = t * triData.angleLeft;
                if (hingeRight) hingeRight.rotation.y = -t * triData.angleRight;
            } else {
                const foldAngle2 = Math.PI - quadData.angles[1];
                const foldAngle3 = Math.PI - quadData.angles[2];
                const foldAngle4 = Math.PI - quadData.angles[3];

                if (hingeLeft) hingeLeft.rotation.y = t * foldAngle2;
                if (hingeRight) hingeRight.rotation.y = -t * foldAngle3;
                if (hingeFarRight) hingeFarRight.rotation.y = -t * foldAngle4;
            }
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isPlaying && currentView === 'fold') {
                animationValue += playDirection * 0.3;
                if (animationValue >= 100) {
                    animationValue = 100;
                    playDirection = -1;
                } else if (animationValue <= 0) {
                    animationValue = 0;
                    playDirection = 1;
                }
                slider.value = animationValue;
                sliderValueLabel.textContent = Math.round(animationValue);
                applyRotation(animationValue / 100);
            }

            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- KH·ªûI CH·∫†Y ---
        function run() {
            init();
            animate();
        }
        run();

    </script>
</body>
</html>